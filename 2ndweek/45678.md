# 4. 변수

## 1. 변수란?

* 메모리: 여러개의 데이터를 저장할 수 있는 공간을 가지고 있으며, 각 공간(메모리 셀)마다 주소를 가지고 있다. ->메모리 주소
* 컴퓨터가 연산을 하기 위해서는 연산되는 숫자들의 주소를 기억하고 있어야 한다. 연산의 결과 값도 메모리에 저장을 해놓아야 한다.
* 연산을 위한 숫자, 연산의 결과값 등을 재사용하기 위해서는 해당 숫자들이 있는 메모리셀에 접근하기위한 방법이 있어야한다. 이 방법을 제공하는 것이 변수이다.
* 프로그래밍 언어는 기억하고 싶은 값을 메로리에 저장하고, 저장된 값을 읽어들여 재사용 하기 위해 변수라는 메커니즘을 제공한다.
* 변수: 하나의 값을 저장할 수 있는 메모리 공간 자체, 또는 그 메모리 공간을 식별하기 위해 붙인 이름.
* 변수 이름을 통해서 언제든지 원하는 메모리 공간에 접근해서 참조 할수 있다. 

## 2. 변수 선언

* 변수를 생성하는 것이다. Var, let, const 키워드를 통해서 선언한다.
* 키워드: 자바스크립트와 약속한 명령어, 자바스크립트는 var, let, const를 만나면 뒤에오는 이름으로 변수를 생성하라 라고 인식한다.
* 변수 선언문이 실행되면, 빈 메모리 공간을 확보하고 메모리 공간의 주소를 기억하는 변수가 생성된다.
* 변수가 생성되고 값을 할당하지 않아도, undefined라는 값으로 변수값이 초기화 된다.
* var, let 키워드는 선언하고 값을 할당하지 않을경우 undefined로 변수값이 자동으로 초기화된다. const의 경우는 값을 선언하고 어떠한 값으로 초기화 해주지 않으면 error message가 발생한다.
* Var(es5 이전 까지), let,const(es6이후 새롭게 도입)
* var 키워드는 스코프 이슈, 중복선언 이슈가 있다.

## 3. 변수 호이스팅

* 자바스크립트 엔진이 자바스크립트를 실행 할 때, 한줄 한줄 순차적으로 처리하기 이전에 코드내의 선언문들을 먼저 처리하기 때문에, 선언문이 코드의 위로 끌어올려진 것처럼 동작하는 것이다.

* let,const로 선언한 변수들은 호이스팅이 되지 않는 것처럼 동작한다.

* ```javascript
  console.log(score);
  var score;//변수 선언문
  score = 10;//변수 할당문
  ```

* 변수 할당문은 코드가 실행되면 한줄한줄 처리되기 때문에, console.log를 할당문 이전에 입력하면 undefined가 출력된다.

## 4. 값의 할당

* 값의 할당= 변수 할당, 할당연산자(=)의 우측에 값이 오고, 좌측에 변수가 온다.
* 값을 저장하기 위해서, 일정크기의 메모리 공간을 확보한다.(다른프로그램이 해당 공간을 사용할 수 없게 된다.)
* 값의 주소는 변수명이 기억하게 되고, 변수명을 통하여 해당 메모리 공간에 저장되어 있는 값을 참조(재사용)할 수 있다.
* 변수는 암묵적으로 undefined로 값이 초기화(최초로 값을 할당하는 것) 된다.
* 특정한 값을 변수에 넣어주게 되면, undefined가 할당된 메모리 공간이 아닌 새로운 공간을 확보하여 특정한 값을 할당하게 된다.undefined는 원시값(변경불가능한 값)이기 때문에 변경될수 없어서 지우고 새로운 값을 넣어줄 수 없기 때문이다.

## 5. 값의 재할당

```javascript
var score = 80;//변수의 선언과 값의 할당
score = 90;//재할당
```

* var score=80;은 하나의 문이지만, 자바스크립트 엔진은 이를 선언과 할당이라는 두가지 과정으로 인식하여 실행시킨다.

  ```javascript
  var score;
  score=80;//이렇게 인식하고 실행시킴.
  ```

* const 키워드로 선언한 변수(상수)는 재할당을 할 수 없다.

## 6. 식별자

* 어떤 값을 구별해내서 식별할 수 있는 고유한 이름이 식별자이다.
* 메모리의 어떤 값(원하는 값)을 정확하게 가져올 수 있는 이름이다.
* 변수의 이름도 식별자이다. 식별자는 값을 기억하고 있는 것이 아니고, 메모리의 주소를 기억하고 있는 것이다. 이를 통해서 원하는 값에 접근할 수 있도록 한다.
* 따라서 식별자는 메모리공간에 붙인 이름이라고 할 수 있다.
* 함수, 클래스의 이름도 모두 식별자이다. 메모리상에 존재하는 어떠한 값을 식별해 낼수 있는 것이라면 모두 식별자이다.
* 식별자에는 네이밍 규칙이 정해져있다.
  * 1) 식별자는 특수문자를 제외한 문자, 숫자, _, $ 를 포함할 수 있다.
  * 2) 식별자는 특수문자를 제외한 문자, _, $ 로 시작할 수 있지만 숫자로는 시작할 수없다.
  * 3) 예약어(키워드로 사용하기 위해서 미리 확보된 단어들)는 식별자로 사용할 수 없다. Ex) function, var, let...
* 식별자는 직관적으로 무언가를 의미하는지를 알 수 있도록 네이밍 하는것이 좋다. 의미없이 x, y..등을 사용하는 것은 좋지않음. 다른 사람이 보았을 때도 이해할 수 있도록하며, 변수의 존재목적을 쉽게 알수 있도록 의미를 명확히 표현해 준다. -> 좋은 변수명은 코드의 가독성을 높여준다.
* 네이밍 컨벤션
  * 1) 카멜 케이스 : var firstName;
  * 2) 스네이크 케이스 : var first_name;
  * 3) 파스칼 케이스 : var FirstName;
  * 4) 헝가리언 케이스 : var strFirstName; //type + identifier

# 5. 표현식과 문

## 1. 값

* value는 어떤 식(표현식)을 평가한 결과를 말한다. 

* 변수는 하나의 값을 저장하기 위해 확보한 메모리 공간 자체 또는 그 메모리 공간을 식별하기 위해 붙인 이름이다. 따라서 변수에는 값을 할당해야 한다.

* ```javascript
  var sum = 10 + 20;//30
  //변수에는 표현식의 평가값인 30이 할당된다.
  ```

* 결국 값은 실제 메모리에 저장되는 최소 단위라고 할 수 있다.

## 2. 리터럴

* 리터럴은 사람이 이해할 수 있는 문자, 약속된 기호를 사용하여 값을 생성하는 방식이다.

* 숫자 3은 단순히 숫자가 아닌 숫자 리터럴이다. 자바스크립트 엔진은 3이라는 리터럴을 읽고 평가하여 숫자값 3을 생성하게 된다. 값을 평가하기 전에는 3이라는 숫자값이 아닌 리터럴3이다.

* 리터럴은 평가되어 값을 생성하는 문자(literal)로 기술된 코드. 사람이 이해할 수 있는 문자(숫자,알파벳,한글 등) 또는 미리 약속된 기호로 이루어져 있다. 리터럴을 이용하여 다양한 종류의 값을 생성할 수 있다.

* 정수리터럴(100), 부동소수점 리터럴(13.4), 2진수 리터럴(0b010001), 8진수 리터럴(0o101), 16진수 리터럴(0x41), 문자열 리터럴 ('hello'), 불리언 리터럴(true, false), null리터럴(null),

  undefined리터럴(undefined), 객체 리터럴({name: 'lee', age: '19'}), 배열리터럴([1,2,3]), 함수 리터럴(function(){}), 정규표현식 리터럴

* **리터럴이라는 표기법을 사용하면 값이 생성된다.**

* 리터럴을 코드에 기술하면, 자바스크립트 엔진은 코드가 실행되는 시점(런타임)에 리터럴을 해석하고 값을 생성한다. **리터럴은 값을 생성하기 위해 미리 약속한 표기법(notation)이라고 할 수 있다.**

## 3. 표현식

* 표현식(expression)은 값(value)으로 평가(evaluation)될 수 있는 문(statement)이다. 즉 **표현식은 평가되어 값을 생성하는 문이다**. 리터럴도 값으로 평가되기 때문에 표현식이다.

* 값으로 평가 될 수 있으면 표현식이다. 식별자도 값으로 평가 될수 있으므로 리터럴이다. 

* 함수는 호출하면 값으로 평가되기 때문에, 함수호출문은 표현식이다. 

* **표현식이라는 것은 값으로 평가된다는 점이 중요하다.**

  ```javascript
  //리터럴 표현식
  10
  'hello'
  //식별자 표현식(선언이 이미 존재한다 가정)
  sum
  person.name
  arr[1]
  //연산자 표현식
  10+20//30으로 평가되기 때문에 표현식
  sum=10
  sum!==10
  //함수/메소드 호출 표현식(선언이 이미 존재한다 가정)
  square()
  person.getName()
  ```

* 표현식과 표현식이 생성한 값은 동등한 관계, 동치(equivalent)이다. 표현식은 값처럼 사용할 수 있다.

## 4. 문

* **문은 프로그램을 구성하는 기본단위이자 최소 실행단위.**

* 프로그램이라는 것은 문들의 집합으로 이루어진 것이며, 문을 작성하고 순서에 맞게 나열한 것이 프로그램이다.

* 문은 여러 토근(token)으로 구성된다. 토큰은 문법적인 의미를 가지며 문법적으로 더이상 나눌 수 없는 코드의 기본요소를 의미한다.

* ```javascript
  var sum = 1 + 2 ;
  // var, sum , =, 1 , +, 2, ; 모두 하나의 토큰들이다.
  ```

* 문은 명령문이라고도 부르며, 컴퓨터에게 내리는 명령이다. 문이 실행되면 명령이 실행되고 무슨 일인가가 일어난다.(ex.변수선언문이 실행되면, 변수가 선언된다.)

* ```javascript
  //변수선언문
  var x;
  // 표현식 문(할당문)
  x=5;
  //함수 선언문
  function foo(){}
  //조건문
  if(x>1){console.log(x);}
  //반복문
  for(var i = 0; i<2; i++){console.log(i);}
  ```

* 문은 세미콜론으로 끝나야 한다. 0개 이상의 문을 중괄호로 묶은 코드블록{...}의 뒤에는 세미콜론을 붙이지 않는다.

* 자바스크립트엔진에는 세미콜론을 문의 끝이라고 예측되는 지점에  자동으로 붙여주는 asi 기능이 있기 때문에 꼭 붙여야 하는것은 아니다. 하지만 개발자의 예측과 다르게 세미콜론이 붙는 경우가 있기 때문에, 붙이는 것이 좋다.

## 5. 표현식인 문과 표현식이 아닌 문

* 변수 선언문은 값으로 평가될 수 없기에 표현식이 아니다.

  ```javascript
  var x;//변수선언문은 값으로 평가 될 수 없다. 변수에 할당 불가.
  ```

* 표현식과 문을 구별하는방법

  * 표현식인문과 표현식이 아닌문으로 구별한다. 표현식인문은 값으로 평가될 수 있는 문이고, 표현식이 아닌문은 값으로 평가될 수 없는 문이다.

* 변수 할당문은 값으로 평가 될 수 있기에 표현식이다. 따라서 할당문은 변수에 할당할 수 있다.

  ```javascript
  var foo = x =100;// 변수 할당문은 100으로 평가 될 수 있기때문에 foo라는 변수에 할당이 될 수 있다.
  ```

* 조건문도 값으로 표현될 수 없기에 표현식이 아니고 변수에 할당될 수 없다.

* 표현식인 문을 실행하면 평가된 값을 반환시킨다. 표현식이 아닌문은 undefined를 반환한다.

# 6. 데이터 타입

## 1. 숫자 타입

* 자바스크립트는 원시타입과 객체타입으로 분류할 수 있다.

* 원시타입(primitive type) : 숫자, 문자열, 불리언, undefined, null, symbol - > 변경할 수 없는 값. immutable value

* 객체타입(object/reference type) : 객체, 함수, 배열 등.

  ->	변경할 수 있는값. mutable value

* 1을 숫자로 선언할 수 있고, 문자로 선언할 수 있다. 숫자타입과 문자열 타입은 확보해야 할 메로리 공간의 크기도 다르고 읽어들여 해석하는 방식도 다르다. 저장되는 2진수도 다르다.

* 값을 생성한 목적과 용도도 다르다. 

* 숫자타입=산술연산을 위해서 생성.  문자타입 = 텍스트를 화면에 출력하기 위해서 생성.

* 자바스크립트는 숫자타입이 단 한가지 종류한다. 실수도 정수도 하나의 타입으로 배정밀도 64비트 부동소수점 형식의 2진수로 저장된다. 여러 진수의 수를 표현하기 위한 데이터 타입의 제공이 없기에, 이들 값을 참조하면 모두 10진수로 해석된다.
* 변수에 값이 할당되는 시점에, 값에 의해서 변수의 타입이 결정된다.
*  infinity, -infinity, NaN(not a number)은 모두 숫자타입이다.

## 2. 문자열 타입

* 문자열은 텍스트 데이터를 나타내는데 사용. 한글자는 16bit(2byte)를 소비한다.

* 전세계 대부분의 문자를 표현할 수 있다. 작은따옴표(''),큰 따옴표(""), 백틱(``)안에 텍스트를 넣어 생성한다.

* 일반적으로 문자열을 만들기 위해서 작은따옴표를 사용한다.

* 작은따옴표로 감싼 문자열 내의 큰따옴표는 문자열로 인식된다.

* 큰 따옴표로 감싼 문자열 내의 작은따옴표는 문자열로 인식된다.

* 작은따옴표로 감싼 문자열 내에 또다시 작은따옴표로 감싼 문자열은 에러를 발생시킨다. syntaxError: unexpected identifier

* 작은따옴표로 다시 감싸주고싶다면 아래와같이 백슬래쉬로 같이 감싸준다.

  ```javascript
  var str = '작은따옴표로 감싼 \'문자열내에 다시 작은따옴표로\' 감싸기';
  ```

* 따옴표로 문자열을 감싸주지 않으면 문자열의 시작과 끝을 알기 어렵고, 식별자와 혼동하기 쉽다.

* ```javascript
  var string = hello;//따옴표로 감싸지 않아서 hello를 식별자로 인식하고 엔진이 hello식별자를 찾기 시작하게 된다.
  ```

* 따옴표로 감싸지 않는다면 스페이스같은 공백을 포함시킬 수 없는 문제도 생긴다.

## 3. 템플릿 리터럴

* es6부터 새롭게 도입된 방법으로 백틱(``)을 이용하여 감싸는 방법이다.

* 일반 문자열 내에서는 줄바꿈을 허용하지 않는다. 템플릿 리터럴 내에서는 줄바꿈이 허용된다.

* 이전까지는 이스케이프 시퀀스를 이용하여 줄바꿈을 해주었다.

* 이스케이프 시퀀스 (ex. '\n'은 줄바꿈, '\t'은 탭..등등)을 사용하지 않으면 es5에서는 문자열 내에서 엔터키를 사용해서 인위적인 개행을 해 줄수 없었다.

* ```javascript
  var template = `<ul>
  	<li>home</li>
  </ul>`; //템플릿 리터럴은 개행이 그대로 문자열로 취급되어 보여진다.
  ```

* 표현식 삽입-> 문자열은 문자열 연산자(+)를 사용하여 연결할 수 있다. + 연산자는 피연산자 중 하나이상이 문자열일 경우, 문자열 연결 연산자로 동작한다.

* ```javascript
  var first = 'yongmin';
  var last = 'kim';
  console.log('my name is' + first + ' ' + last);//es5방식의 문자열 연결
  ```

* ```javascript
  console.log(`my name is ${first} ${last}.`); //es6이후의 표현식 삽입방식.
  ```

* 표현식 삽입은 표현식의 평가 결과가 문자열이 아니더라도 강제 타입 변환되어 삽입된다.

  ```javascript 
  console.log(`1+2=${1+2}`);//1+2=3으로 출력
  ```

## 4. 불리언 타입

* 불리언 타입은 논리적 참(true), 거짓(false)를 나타낸다.
* 프로그램의 흐름을 제어하는 조건문에서 자주 사용된다.

## 5. Undefined 타입

* 선언이후에 명시적으로 값을 할당하지 않은 변수는, 자바스크립트 엔진에 의해서 암묵적으로 초기화되는데, undefined값을 갖게된다.
* 주 목적은, 선언하였지만 초기화 하지않은 변수에 자바스크립트 엔진이 암묵적으로 값을 할당해주기 위함이다. 개발자가 인위적으로 이 값을 변수에 넣어줄 일은 없다. 이는 혼란을 가중시킨다.
* 우리가 어떠한 값을 참조하였을때, undefined를 출력받는다면 이 값에는 아무것도 할당해주지 않았다고 생각하기 때문에, 인위적으로 할당해주면 다른 개발자들의 혼란이 커진다.
* 변수에 값이 없다고 얘기해주고 싶은 경우에는 null을 할당해주도록 한다.

## 6. null 타입

* null type은 null이 유일하다. 대소문자를 구분하기때문에 null이라고 기입한다.
* 어떤 변수를 참조하였을때, null이 나오면 개발자가 의도적으로 값이 없다는것을 명시하려 한것을 알 수 있다.
* 함수가 반환할 값이 없을경우에는 null을 반환하기도 한다.

## 7.symbol타입

* es6에 새롭게 추가된 변경불가능한 원시타입이다.

* 이 값은 리터럴이 존재하지 않고 반드시 symbol함수를 통해서 생성한다.

* ```javascript
  var key = Symbol('key');//심볼값 생성함수
  ```

## 8. 객체타입

* 원시타입이 아닌 모든것들을 객체타입이라고 부른다.
* 자바스크립트는 객체기반의 언어로, 거의 대부분이 객체로 이루어져 있다. 다른장에서 집중적으로 다룰것,,,

## 9. 데이터 타입의 존재 이유

* 자바스크립트 엔진은 데이터타입, 값의 종류에 따라 정해진 크기의 메모리 공간을 확보한다. 변수에 할당되는 값의 데이터 타입에 따라서 확보해야할 메모리 공간의 크기가 결정된다.

* 값을 참조할 때, 몇 바이트를 한번에 읽어들여야 할지 결정해야 한다. 8바이트짜리 데이터를 4바이트만 읽어들인다면, 데이터가 훼손되어서 보여진다.

* 값을 데이터 타입에 의해서 잘 저장하고 잘 읽어들일수 있게 한다.메모리에서 읽어들인 2진수를 어떻게 해석해야 하는지에 대한 문제가 남아있다. ->2진수는 어떻게 해석하는지에 따라서 전혀 다른값이 된다. 

* ex> 01000001을 숫자로 해석하면 65이지만, 문자열로 해석하면 

  'A'이다. **저장되어있는 2진수의 해석방법을 알아야 원하는 데이터를 출력할 수 있다. 이러한 해석방법을 제공하는 것이 데이터 타입이다.**

* 데이터 타입이 없다면, 메모리에 저장할 때, 얼마만큼의 메모리 공간을 확보해야 하는지, 데이터를 참조할 때 몇 바이트 단위로 읽어들여야 하는지, 메모리에 저장된 2진수 값을 어떻게 해석해야 하는지도 알 수 없게 된다.

* 1) 값을 저장할 때 확보해야 하는 메모리 공간의 크기를 결정

* 2) 값을 참조할 때 한번에 읽어 들여야 할 메모리 공간의 크기를 결정하기 위해

* 3) 메모리에서 읽어들인 2진수를 어떻게 해석할 지를 결정하기 위해

## 10. 동적 타이핑

* 자바스크립트의 모든 값은 데이터 타입을 갖는다.

* 정적타입 언어는 변수 선언시 데이터 타입을 명시해야 한다.

* 정적타입 언어는 변수의 타입의 변경이 불가하며, 타입체크를 통과하지 못하면 에러가 발생하며 프로그램 실행이 막힌다.

* 이렇게 일관성을 강제하여 안정적인 코드를 구현시킨다.

* 자바스크립트는 동적타입 언어로써, 변수선언시 데이터 타입을 선언하지 않고 var 키워드를 이용한다.

* typeof 연산자로 데이터 타입을 조사할 수 있다.

* null은 typeof 로 데이터 타입을 조사하면 object가 출력된다.(주의)

* 변수의 타입이 있을까? -> typeof로 변수의 타입을 출력시키면 나오는 값은 변수의 타입이 아니라, 변수에 현재 할당되어 있는 값의 타입을 반환하는 것이다.

* 자바스크립트는 어떤 타입의 값이라도 자유롭게 할당이 가능하다. 정적언어와는 다른 데이터 타입의 개념을 가지고 있다. 값을 할당하는 시점에 변수의 타입이 동적으로 결정되며, 변수의 타입은 고정되어 있지 않고, 재할당 되는 값에 의해서 언제든지 동적으로 변할수 있다.

* 따라서, **기본적으로 변수는 타입을 갖지 않는다.(var) 하지만 값은 명확히 타입을 가지고 있다. 값의 타입에 따라서 변수의 타입이 동적으로 변경되는 것이다.**

* 이러한 편리한 변수타입 변경 가능성은 이점도 있지만 단점도 있다. 현재 변수내의 값을 추적하기에 어려울 때가 있다. 정적타입 언어는 한번 선언한 타입이 변하지 않기에, 이로인해서 곤란할 일이 없지만 자바스크립트에서는 변수의 타입이 값의 타입에 의해서 변하기 때문에, 변수내의 값에 정확히 이해가 없다면 이를 잘못 예측하여 오류를 발생시키기 쉽다. 

  (편리성 high, 신뢰성 low->trade-off)

* 모던 자바스크립트에서는 타입을 가지고있는 타입스크립트를 많이 사용하기도 한다.

* 변수를 사용하지 않을 수 없지만, 되도록이면 변수의 사용을 적극적으로 줄여서 오류 발생 가능성을 낮추자.

* 전역변수(어디에서든 참조할 수 있는 변수)의 사용을 금하자.

* 변수의 생명주기(스코프)를 최대한 짧게 만들도록 한다.

* 변수의 값이 변하는 경우가 아니라면, 변수보다는 상수를 사용하여 값의 변경을 억제하는 것이 좋다. **const** 키워드를 사용하면 상수 선언이 가능하다.

* 변수를 이름지을 경우, 변수의 존재 이유를 파악할 수 있도록 명명한다. -> 오해를 불러일으키거나 실수를 야기할 가능성이 낮아진다.

# 7. 연산자

## 1,2 . 이항 산술 연산자 & 단항 산술 연산자

* **연산자는 하나 이상의 표현식(피연산자)을 대상**으로 산술, 할당, 비교, 논리, 타입, 지수연산 등을 수행해 하나의 값을 만든다.

* 연산자 표현식(피연산자+연산자)도 값으로 평가되어지는 표현식이 된다.

* 피 연산자가 값이라는 명사의 역할을 한다면, 연산자는 피연산자를 연산하여 새로운 값을 만든다 라는 동사의 역할을 한다.

* 1) 산술 연산자 : 피연산자를 대상으로 수학적 계산을 수행해 새로운 숫자 값을 만듬. 연산이 불가능한 경우 NaN을 반환한다. -> NaN은 숫자타입의 값이다.

  ​	산술연산자는 피연산자의 개수에 따라서, 이항산술 연산자와 단항산술 연산자로 구분된다.

  ​	 (1) 이항산술 연산자 : +,-,*,/,%

  ​	 (2) 단항산술 연산자 : 피연산자가 1개인 연산자. 

  ​		++, --,  +,  -(부호 반전)

  ​		`++와 --는 변수의 앞 뒤에 붙는 차이로 할당후 증감, 		할당	전 증감이 결정된다.`

  ​		`+뒤에 문자가 오면 ex>+'10' , 문자열이 숫자로 타입변환된다.단, 피연산자인 '10'을 직접수정이 아니고 숫자값으로 변형을 해서 새로운숫자를 만드는것이다. 직접 변하는 것은 아니다.`

* ```javascript
  var x='10';
  console.log(+x); //숫자10 출력
  console.log(typeof +x); // number출력
  //x에 할당된 문자열 10 자체가 숫자 10이 된 것은 아니다!!! 변함없이 string이다. ->부수효과 없다.(x에 할당된 변수값을 재할당해서 변경하지 않는다.)
  ```

* ```javascript
  var y = 1;
  console.log(++y); //2
  console.log(y);// 2 
  //++연산자를 이용하면 y의 값 자체를 재할당시킨다.
  ```

* 대부분의 연산자들은 부수효과가 없다. 그러나 세 가지 부수효과를 가진 피연산자가 있다.

```javascript
-(-10); // 10 부호를 반전
-'10'; // -10 문자열을 숫자로 타입 변환
-true; // -1 불리언 값을 숫자로 타입변환
-'hello'; // NaN 문자열을 숫자로 변환시킬 수 없음.
//모두 부수효과는 없다.
```

## 3. 문자열 연결 연산자

* 연산자는 피연산자 중 하나 이상이 문자열인 경우, 문자열 연결 연산자로 동작한다.

* ```javascript
  1 + true; // 2 true는 1로 타입변환
  1 + false; // 1 false는 0으로 타입변환
  1 + null; // 1 null은 0으로 타입변환
  +undefined; //NaN  undefined는 숫자로 변환x
  1 + undefined; //NaN
  ```

* 이처럼 자바스크립트 엔진은 *암묵적 타입변환* 또는 타입 강제변환이 빈번하게 일어난다.

## 4. 할당 연산자

* 할당연산자는 우항에 있는 피연산자의 평가 결과를 좌항에 있는 변수에 할당한다.

  | 할당 연산자 | 사례  | 동일표현 | 부수효과 |
  | ----------- | ----- | -------- | -------- |
  | =           | x = 5 | x = 5    | O        |
  | +=          | x+=5  | x=x+5    | O        |
  | -=          | x-=5  | x=x-5    | O        |
  | *=          | x*=5  | x=x*5    | O        |
  | /=          | x/=5  | x=x/5    | O        |
  | %=          | x%=5  | x=x%5    | O        |

* 할당연산자는 변수에 재할당이 이루어 지기 때문에 부수효과가 존재한다.

## 5. 비교 연산자

* 좌항과 우항의 피연산자를 비교한 다음 그 결과 불리언 값을 반환한다.

* 동등/일치 비교연산자

  | ==   | 동등비교   | x==y  | x와 y의 값이 같다.          | 부수효과 x |
  | ---- | ---------- | ----- | --------------------------- | ---------- |
  | ===  | 일치비교   | x===y | x와 y의 값과 타입이 같다.   | 부수효과x  |
  | !=   | 부동등비교 | x!=y  | x와 y의 값이 다르다.        | 부수효과x  |
  | !==  | 불일치비교 | x!==y | x와 y의 값과 타입이 다르다. | 부수효과x  |

  * 동등비교연산자를 사용하면, 암묵적 타입변환이 일어나서 같은 타입으로 맞춰진 후 비교 된다.

  * 동등비교 연산자는 결과를 예측하기 어렵다. 결과예측이 곤란하기 때문에, 동등비교 연산자를 사용하지 않고 일치비교 연산자를 사용하도록 하자.

* 일치비교 연산자를 사용하는 경우에는 NaN사용시 주의해야한다.

* ```javascript
  NaN === NaN;//false, nan은 자기자신과 일치하지 않는 유일한 값이다.
  ```

* isNaN();함수를 이용해서 NaN인지 아닌지 조사하도록 하자.

* +0과 -0도 일치비교시 같다고 판단되기 때문에, +0과 -0을 엄격히 판단해야 할 경우에는 Object.is(-0,+0);을 사용한다.

## 6. 삼항 조건 연산자

* 피연산자가 3개이다.

* ```javascript
  var result = x % 2 ? '홀수':'짝수'; 
  //조건식이 참 일 경우, 홀수가 반환, 거짓일경우 짝수가 반환된다.
  ```

## 7. 논리 연산자

* || : OR의 의미를 갖고있다.

* && : AND의 의미를 갖고있다.

* ! (논리부정 연산자) :반대의 논리연산을 한다.

* 단축평가 : 'cat' && 'dog'; //dog로 출력된다. 'cat'은 true로 평가되기 때문에 dog에 의하여 결과값이 결정되기 때문이다. 뒤에서 자세히 다룬다.

* 쉼표연산자 : 왼쪽 피연산자 부터 차례대로 피연산자를 실행, 평가하고 마지막 피연산자의 평가가 끝나면 마지막 피연산자의 평과결과를 반환한다.

  ```javascript
  var x,y,z;
  x = 1, y = 2, z = 3; //3
  ```

* 그룹 연산자: 피연산자인 표현식을 가장 먼저 평가한다.()를 이용하여 감싸면 연산자의 우선순위를 조절 할 수 있다. ()안의 내용이 더 우선적으로 연산되도록 한다. 

## 8. typeof 연산자

* 피연산자의 데이터 타입을 문자열로 반환한다.
* null을 반환하는 경우는 없으며, 함수의 경우에는 object가 아닌 function을 반환한다. null은 object를 반환하는데, 이는 자바스크립트의 버그이다.

## 9. 지수 연산자

* 좌항의 피연산자를 밑으로, 우항의 피연산자를 지수로 거듭 제곱하여 숫자 타입의 값을 반환한다.

* ```javascript
  2 ** 2;//4
  2 ** 2.5; // 5.656854....
  2 ** 0; //1
  2 ** -2; // 0.25
  -5 ** 2;// 문법에러
  (-5) **2; //25 ->음수는 반드시 괄호로 묶어줘야한다.
  ```

* 지수 연산자가 도입되기 이전에는 Math.pow메소드를 사용하였다.
* Math.pow(2,2); -> 4 >>>가독성이 지수연산자보다 떨어지며, 여러 제곱의 관계가 나오면 가독성이 매우 떨어진다.
* 지수연산자는 모든 이항 연산자보다 우선 순위가 높다.

# 8. 제어문

* 주어진 조건에 따라서 코드 블록을 실행하거나 반복 실행할 때 사용한다. 일반적으로 코드는 위에서 아래로 순차적으로 실행된다. 제어문을 사용하면 코드의 실행 흐름을 인위적으로 제어할 수 있다.
* 코드의 실행 순서가 변경되면, 단순하게 위->아래로 순차적으로 진행하는 직관적 코드흐름을 혼란스럽게 한다.
* 제어문은 코드의 흐름을 이해하기 어렵게 만들어서 가독성을 해치는 단점이 있다.
* 고차함수를 사용한 함수형 프로그래밍에서는 제어문의 사용을 억제하여 복잡성을 해결하려고 노력한다.

## 1. 블록문

* 코드블록: 여러개의 문을 하나의 실행단위로 그룹화 한다.
* 블록문(코드블록): 0개 이상의 문을 중괄호로 묶은 것으로 코드블록/블록 이라고 부른다.
* 단독으로 블록문을 사용할 수도 있으나, 제어문이나 함수 선언문에서 사용하는 것이 일반적이다. ;을 붙이는것이 일반적이지만, 블록문의 끝에는 ;을 붙이지 않는다.

## 2. 조건문

* 주어진 조건식의 평과 결과에 따라서 코드블럭의 실행을 결정한다. 조건식은 불리언값으로 평가될 수 있는 표현식이다.

* If...else문과 switch문을 제공한다.

* If...else문

  * if라는 키워드를 사용하고 조건식과 else를 동반한다.
  * if(조건식)에서 조건식이 0 또는 1이 주어진다면, 자바스크립트 엔진에서 암묵적으로 타입변환을 실행하여 불리언 값으로 형변환 시킨다.
  * 조건식은 한 개 이상일 수  있다. 2번째 조건부터 else if(조건식2...)로 표기해준다. ->여러개의 조건을 줄 수 있다.

* 코드 블록 내의 문이 하나뿐이라면, 중괄호를 생략할 수 있다.

  ex> if(조건) return a;

## 3. switch 문

```javascript
switch(표현식){
  case 표현식1:
    switch 문의 표현식과 표현식1이 일치하면 실행될 문;
    break;  
  case 표현식2:
  	switch 문의 표현식과 표현식2가 일치하면 실행될 문;
    break;
  default:
  	switch 문의 표현식과 일치하는 표현식을 갖는 case문이 없을 때 실행될 문;    
}
```

* switch문의 표현식은 값보다는 문자열, 숫자 값인 경우가 더 많다. 반드시 불리언 값이어야 할 필요가 없다. 
* 논리적인 참, 거짓보다는 다양한 case에 따라 실행할 코드 블록을 결정할 경우 사용한다. 
* fall through : 표현식이 자신과 일치하는 case 표현식n을 찾아서 실행되고 나면, 그뒤에 있는 case들을 모두 실행시키는 현상이다. 따라서 이를 방지하기 위해서 case마다 break키워드를 추가하여 방지해준다.
* Break->제어문의 코드블록을 탈출 할 수 있도록 한다.
* default문은 가장 마지막에 써주고, 가장 마지막이기 때문에 폴스루 현상이 발생하지 않아서 break문이 필요가 없다.
* switch 문은 if..else문 보다 복잡하다. 따라서 되도록이면 if..else문으로 해결할 수 있는경우라면 if..else문을 사용하도록 하자.

## 4. 반복문 (for문, while문, do-while문, for in, for of문..forEach문)

* ```javascript
  //for문
  for(var i =0; i<2; i++){//변수선언/할당문,조건식,증감문 ->조건식이 false가 될때까지 반복실행
    console.log(i); //0 1
  }
  ```

* ```javascript
  //while문
  var count = 0;
  while(count < 3){
    console.log(count);
    count++;
  }//0 1 2
  ```

* 조건식의 평가 결과가 참이면 코드블록을 계속해서 반복 실행한다. 조건문의 평가 결과가 거짓이 되면 실행을 종료한다.

* 증감문이 없다면 무한루프에 빠지게 된다.

* 조건식 while(true)를 써주면 무한대로 돌아가게 되므로 탈출 조건을 if, break를 사용하여 만들어 준다.

* ```javascript
  var count = 0;
  do{
    console.log(count);
    count++;
  }while(count <3 );
  //do while문은 코드블록이 최소 한번은 실행된후에 조건식을 판단하여 계속할지 멈출지 결정된다.
  ```

## 5. break문

* 코드 블록을 탈출한다. 레이블문, 반복문, switch문의 코드 반복을 멈추고 나갈 수 있게해준다.

* 레이블 문(label statement) : 식별자가 붙은 문이다,

  ``` javascript
  foo: console.log('foo');
  //foo라는 레이블 식별자가 붙은 레이블 문
  ```

  ```javascript
  foo: {//foo라는 식별자가 붙은 레이블 블록문
    console.log(1);
    break foo;//foo레이블 블록문을 탈출한다.
    console.log(2);
  }
  console.log('Done!');
  ```

## 6.continue 문

* 코드블록 실행을 현지점에서 중단하고 반복문의 증감식으로 이동한다. break문과는 다르게 반복문 자체를 탈출하지는 않는다.

# 9.타입 변환과 단축 평가

## 1. 타입변환이란?

* 개발자가 의도적으로 값의 타입을 변환하는 것을 명시적 **타입변환(Explicit coercion)** 또는 **타입캐스팅(Type casting)**이라 한다.

* ```javascript
  var x = 10;
  var str = x.toString(); //문자열로 타입을 변환
  console.log(typeof str, str);//string 10
  ```

* 주의점: x에 있던 숫자값이 변경된 것은 아니다. 새로운 문자열 값을 만든것이지, 숫자값 10을 직접 변경한 것은 아니다.

* 암묵적 타입변환(Implicit coercion) : 개발자의 의도와는 상관없이 표현식을 평가하는 도중에 자바스크립트 엔진에 의해 암묵적으로 타입이 자동변환 되는 것 = 타입강제변환(type coercion)

* ```javascript
  var x = 10;
  var str = x + '';//숫자값 10을 이용해서 문자열 '10'을 생성하게 된다.
  console.log(typeof str, str);
  //타입변환이란 기존 원시값을 사용해, 다른 타입의 새로운 원시값을 생성하는 것이다.
  ```

* 명시적 타입 변환은 개발자의 의지가 코드에 드러나기 때문에 가독성이 좋지만, 암묵적 타입변환은 코드에 드러나지 않기때문에 예측을 하지 못한다면 오류를 생산할 가능성이 높아진다.

* 그러나 경우에 따라서는 암묵적 타입변환이 가독성이 더 좋을 수 있다.

  ```javascript
  (10).toString()//명시적
  10 + ''//암묵적
  //이 경우에는 암묵적 타입변환이 더 간결하고 가독성 측면에서 이해하기 쉽다.
  ```

  ## 2. 암묵적 타입변환

  * 자바스크립트 엔진이 표현식을 평가 할 때, 개발자의 의도와는 상관없이 코드의 문맥을 고려하여 암묵적으로 데이터 타입을 강제변환

  * ```javascript
    '10' + 2 //'102'
    5 * '10' // 50
    1 - '1'//0(숫자)
    
    //피연산자 또는 표현식이 불리언 타입이어야 하는 문맥
    !0 //true
    if(1){ }//if문의 조건식의 자리에 0 또는 1이 올경우 false 와 true로 암묵적 타입변환을 실시
    ```

  * 이처럼 표현식을 평가할 때, 가급적으로 에러를 발생시키지 않도록 암묵적 타입변환을 통해 표현식을 평가한다.

  * ```javascript
    console.log(`1+1 = ${1+1}`); //"1+1 = 2"
    //템플릿 리터럴에서 ${}내의 숫자 1+1은 문자열2로 암묵적 타입변환된다.
    ```

  * es6에서 새롭게 도입된 심볼타입에서는 암묵적 타입변환이 실행되지 않는다.

  * ```javascript
    //단항연산자를 이용한 타입변환
    +'' // 0
    +'0' // 0
    +'1' // 1
    +'string' //NaN
    +true //1
    +false //0
    +null //0
    +undefined // NaN
    ```

  * ```javascript
    if ('') console.log('1');
    if (true) console.log('2');
    if (0) console.log('3');
    if ('str') console.log('4');
    if (null) console.log('5');
    // 2 4 ->Truthy 와 Falsy에 의해서 나온 결과이다.
    ```

  * Truthy와 Falsy

    False, undefined, null, 0, -0, NaN, ''(빈 문자열) -> 이 값들 이외의 것들은 모두 Truthy이다.

##   3. 명시적 타입 변환

* 개발자의 의도에 의해서 타입을 변경. 
* 암묵적 타입변환을 이용하여 명시적 타입변환을 하는 방법도 있다.
* String()을 이용하여 문자열로 타입변환 해줄 수 있다.
* x.toString()을 이용하여 문자열로 타입변환 해줄 수 있다.
* 1 + ''을 이용하여 문자열로 타입변환 해줄 수 있다. (암묵적 타입변환을 명시적변환으로 이용)
* parseInt(정수로 변환), parseFloat(실수로 변환, 소수점 포함) 함수는 문자열만 숫자타입으로 변환 가능하다.
* Number()을 이용하면 문자열을 숫자타입으로 변환 가능하다.
* 문자열앞에 +를 붙여주거나 1을 곱해주면 문자열을 숫자로 간편하게 변환할 수 있다.

## 4. 단축평가

* 논리합( || ), 논리곱( && )연산자 표현식의 평가 결과는 불리언 값이 아닐 수도 있다. 논리합, 논리곱 연산자 표현식은 언제나 2개의 피연산자 중 어느 한쪽으로 평가된다.

* ```javascript
  'cat' && 'dog'// 'dog'
  //cat은 truthy값이므로 true로 평가되기 때문에, 이 표현식의 결과는 뒤의 'dog'에 의해서 결정지어 지므로 'dog'를 반환한다.
  //앞에 falsy가 온다면 falsy값을 바로 반환한다.
  ```

* 논리합 연산자는 두개의 피연산자 중 하나만 true로 평가되어도 true를 반환한다.

  ```javascript
  'cat' || 'dog' //'cat' -> 앞의 truthy값만으로 값의 평가가 가능하기 때문에 'cat'을 반환한다.
  ```

* **단축평가는 표현식을 평가하는 도중에 평가 결과가 확정된 경우, 나머지 평가 과정을 중단하는 것이다.**

  * | 단축평가 표현식     | 평가결과 |
    | ------------------- | -------- |
    | true \|\| anything  | true     |
    | false \|\| anything | anything |
    | true && anything    | anything |
    | false && anything   | False    |

* 단축평가를 사용하면 if 문을 대체할 수 있다. 

  * 주어진 조건이 truthy값 일때, 무언가를 해야한다면, 논리곱 연산자(&&) 표현식으로 if문을 대체할 수 있다.

    ```javascript
    var done = true;
    var message = '';
    
    //주어진 조건이 true일 때
    if (done) message = '완료';
    
    //if 문은 단축 평가로 대체 가능하다.
    message = done && '완료';//done이 true지만 뒤의 완료에 의해서 값이 평가되기 때문에 '완료'가 message에 할당된다.
    console.log(message); // 완료
    ```

  * 주어진 조건이 Falsy값 일 때, 무언가를 해야한다면 논리곱연산자(||)표현식으로 if문을 대체할 수 있다.

    ```javascript
    var done = false;
    var message = '';
    //주어진 조건이 false일 때,
    if (!done) message = '미완료';
    //if문은 단축평가로 대체 가능
    message = done || '미완료';
    console.log(message);//미완료
    ```

  ## 5. 논리 연산자

  * 우항과 좌항의 피연산자를 논리 연산한다.

  * &&, || , !(논리부정)

  * 논리부정연산자는 언제나 불리언 값을 반환하지만, 피연산자가 반드시 불리언 값일 필요는 없다. 만약 피연산자가 불리언값이 아니라면, 불리언 타입으로 암묵적 타입변환된다.

  * 드 모르간의 법칙

    ```javascript
    !(x || y) === (!x && !y)
    !(x && y) === (!x || !y)
    ```

  ## 6. 쉼표 연산자

  * 쉼표(,)연산자는 왼쪽 피연산자부터 차례대로 피연산자를 평가, 마지막 피연산자의 평가가 끝나면 마지막 평가 결과를 반환한다.

    ```javascript
    var x, y, z;
    x = 1, y = 2, z = 3; //3
    ```

  

  # 10. 객체 리터럴

  ## 1. 객체란?

  * 다양한 타입의 값(원시값 또는 다른 객체)들을 하나의 단위로 구성한 복합적인 자료구조이다. 원시값은 변경불가능한 값이지만, 객체 타입의 값, 즉 객체는 변경가능하다.

  * 자바스크립트에서 사용하는 모든 값들은 프로퍼티 값으로 사용 될 수 있다.

  * 자바스크립트의 함수는 일급 객체이므로 값으로 취급할 수 있다. 따라서 프로퍼티 값에 함수가 올 수 있다. 이 경우의 함수는 메소드 라고 부른다.
  * 객체는 0개 이상의 프로퍼티를 포함해야 한다. 따라서 프로퍼티가 있을수도 , 메소드가 있을수 없을수도 있다.
  * 프로퍼티: 객체의 상태를 나타내는 값(data), 메소드: 프로퍼티(상태 데이터)를 참조하고 조작할 수 있는 동작(behavior)

  ## 2. 객체 리터럴에 의한 객체 생성

  * 인스턴스(instance): 클래스에 의해 생성되어 메모리에 저장된 실체이다. 클래스는 인스턴스를 생성하기 위한 템플릿의 역할을 한다. 인스턴스는 객체가 메모리에 저장되어 실제로 존재하는 것에 초점을 맞춘 용어이다.

  * 자바스크립트는 프로토타입 기반 객체지향 언어로써, 클래스 기반 객체지향 언어와는 다른 다양한 객체생성 방법이 존재

    * 1) 객체 리터럴
    * 2) object 생성자 함수
    * 3) 생성자 함수
    * 4) object.create 메소드
    * 5) 클래스(es6)

  * 객체 리터럴:  객체를 생성하는 표기법. 객체 리터럴은 중괄호 내에 0개 이상의 프로퍼티를 정의한다. 변수에 할당이 이루어지는 시점에 자바스크립트 엔진은 객체 리터럴을 해석하여 객체를 생성한다.

  * 프로퍼티를 정의하지 않으면 빈 객체가 생성된다.

    ````javascript
    var empty= {}; //빈객체
    console.log(typeof empty);//object
    ````

  * 객체 리터럴의 중괄호는 코드블록을 의미하지 않는다. 코브블록의 닫는 중괄호 뒤에는 세미콜론을 붙이지 않는다. 하지만 객체 리터럴은 값으로 평가되는 표현식이다. 따라서 객체리터럴의 닫는 중괄호 뒤에는 세미콜론을 붙인다.

  * 객체 리터럴은 자바스크립트의 유연함과 강력함을 대표하는 객체 생성방식이다. 객체를 생성하기 위해 먼저 클래스를 정의하고 new 연산자와 함께 생성자를 호출할 필요가 없다. 객체를 생성한 이후에 프로퍼티를 동적으로 추가할 수도 있다.

  

  ## 3. 프로퍼티

  * 객체는 프로퍼티들의 집합이며, 프로퍼티는 키와 값으로 구성된다. 프로퍼티는 쉼표로 구분해서 나열한다. 마지막 프로퍼티의 뒤에는 쉼표를 쓰지않아도 된다.

  * 프로퍼티 키: 빈문자열을 포함하는 모든 문자열 또는 symbol 값

  * 프로퍼티 값: 자바스크립트에서 사용할 수 있는 모든 값

  * 프로퍼티 키 명명 규칙

    ```javascript
    var person = {
      firstname: 'yongmin',
      'last-name': 'kim'
    }; //last-name의 마이너스기호는 네이밍규칙에 위배되므로 따옴표를 생략 할 수 없다.
    ```

  * 빈 문자열을 프로퍼티 키로 사용해도 에러는 발생하지 않지만, 키로써(식별자의 한종류 로써) 의미를 갖지 못하므로 하지말자.

  * 프로퍼티 키를 0,1,2 같이 숫자로 명명해준다면, 암묵적 타입변환을 통해서 문자열이 된다. 내부적으로 모두 문자열로 변환된다.

  * 프로퍼티 키에 예약어를 프로퍼티 키로 사용해도 에러가 발생하지 않지만, 예상치 못한 에러가 발생할 수 도 있으므로 하지말자.

  * 이미 존재하는 프로퍼티 키를 중복선언하면 나중에 선언한 프로퍼티가 덮어 쓰게 된다. 에러는 발생하지 않으므로 주의하자.

  

  ## 4. 메소드

  * 자바스크립트에서는 프로퍼티 값으로 모든값을 사용할 수 있다.(함수도 값으로 취급된다.)
  * 프로퍼티 값이 함수일 경우, 일반 함수와 구분하기 위해서 메소드라고 부른다. 메소드는 객체에 제한되어 있는 함수를 의미한다.



	## 	5. 프로퍼티 접근

   * 마침표 표기법(dot notation) 또는 대괄호 표기법(bracket notation)을 사용하여 프로퍼티 값에 접근한다.

   * 프로퍼티 키가 식별자 네이밍 규칙을 따르는 이름, 자바스크립트에서 사용가능한 유효한 이름이면 마침표 표기법과 대괄호 표기법 모두 사용가능.

   * 마침표 또는 대괄호의 좌측에는 객체로 평가할 수 있는 표현식을 기술. 마침표의 우측 또는 대괄호의 내부에는 프로퍼티 키를 지정

   * ```javascript
     var person = {
       name: 'kim'
     };
     
     console.log(person.name); //kim 마침표 표기법
     console.log(person['name']); //kim 대괄호 표기법 , 따옴표가 없으면 name을 프로퍼티 키가아닌 식별자로 인식하여 에러.
     ```

   * 객체에 존재하지 않는 프로퍼티에 접근한다면, undefined를 바환한다. referenceError가 발생하지 않음. 주의!

   * ```javascript
     var person = {
       'last-name': 'kim',
       1: 10
     };
     
     console.log(person['last-name']);//kim
     console.log(person['1']); // 10
     console.log(person[1]);//10 ->이것이 가능한 이유는 1을 내부적으로 문자열로 변환하기 때문이다.
     //위의 대괄표 표기법으로 참조해야 하는 경우.
     ```

   * 프로퍼티를 삭제하고 싶은경우는 delete연산자를 사용한다.

   * ```javascript
     var person ={
       name: 'kim'
     };
     person.address = 'seoul';
     
     delete person.address;//동적으로 추가된 프로퍼티를 삭제했다.
     delete person.age;//존재하지 않는 프로퍼티를 삭제하려 할 경우는 에러가 발생하지 않고 무시된다.
     ```



## 6. ES6에 추가된 객체 리터럴의 확장 기능

* 1) 프로퍼티의 축약표현 (프로퍼티 값으로 사용한 변수와 프로퍼티 키가 같은경우)

  ```javascript
  //ES5
  var x = 1, y = 2;
  var obj={
    x:x,
    y:y
  };
  console.log(obj); // {x:1, y:2}
  
  //ES6
  let x = 1, y = 2;
  const obj = { x, y };//프로퍼티 축약표현
  console.log(obj);//{x:1, y:2}
  ```

* 2) 메소드 축약표현

  ```javascript
  //es5
  var obj = {
    name: 'kim',
    sayHi: function(){
      console.log('hi! ' + this.name);
    }
  };
  obj.sayHi(); // hi! kim
  
  
  //es6
  const obj = {
    name: 'kim',
    sayHi() {//이것이 함수의 이름이자 키가 된다.
      console.log('hi! ' + this.name);
    }
  };
  obj.sayHi(); // hi! kim
  //이 방식은 es5 es6의 함수가 내부적으로는 다르게 동작한다는 것을 인지하자.
  ```

  

# 11. 원시 값과 객체의 비교

## 1. 변경 불가능한 값

* 원시 타입의 값: 변경 불가능한 값,  객체(참조) 타입의 값: 변경 가능한 값

* 원시값을 변수에 할당하면 변수에는 실제 값이 저장된다. 객체를 변수에 할당하면 변수에는 참조 값이 저장된다.

* 원시값을 갖는 변수를 다른 변수에 할당하면, 원본의 원시값이 복사되어 전달. (값에 의한 전달)

* 객체를 가리키는 변수를 다른 변수에 할당하면 원본의 **참조값**이 전달(참조에 의한 전달)

* 원시 값: 한번 생성된 원시값은 read only 한 값이므로, 변경할 수 없다. 변수라는것은 메모리 공간을 가르키기도 하고 그 메모리공간에 붙은 이름을 말하기도 한다. 값은 변수에 저장된 데이터로써 표현식이 평가되면서 생성된 결과이다. 변경 불가능한것은 변수가 아니라 값이다.

* 값을 변경할 수 없다는 것은 재할당을 할 수 없다는 의미와는 다르다. **변수는 언제든지 재할당을 통해서 변수값을 변경할 수 있다.**

* 상수도 값을 저장하기 위한 메모리 공간이 필요하므로 변수라고 할 수 있다. **상수는 재할당이 금지된 변수이다.** 상수와 변경 불가능한 값을 동일시 하는것은 곤란하다.

* 자바스크립트는 es5까지는 상수를 표현할 수 없었다. es6에서  const키워드가 도입이 되면서 상수를 선언할 수 있게 되었다. const는 선언과 동시에 값을 할당해주어야 한다. 

* const 키워드를 사용해서 선언한 상수에 할당된 객체는 변경할 수 있다. 재할당이 금지된 변수일 뿐이다.

  ```javascript
  const o = {};
  o.a = 1;
  console.log(o); // {a:1}
  ```

* 원시값은 불변성을 갖으며, 한번 생성된 값은 절대로 변경될 수 없다. 재활당으로 값을 교체해주는 방법 밖에 없다.

## 2. 문자열과 불변성

* 원시타입별로 메모리 공간의 크기가 미리 정해져 있다. 숫자의 경우는 8byte를 차지하며, 문자열(0개 이상의 문자들로 이루어진 집합)은 한개의 문자는 2byte를 사용한다. ->10개의 문자로 이루어진 문자열은 20byte가 필요하다.

* 자바스크립트는 개발자의 편의를 위해서 원시타입인 문자열타입을 제공한다. 문자열은 원시타입이기 때문에 생성된 이후에 변경이 가능하지 않다.

* 유사 배열 객체(array-like object)

  : 유사배열 객체는 마치 배열처럼 인덱스로 프로퍼티 값에접근할 수 있고, length프로퍼티를 갖는 객체이다. 문자열은 배열처럼 인덱스를 통해서 각 문자에 접근할 수 있으며,  length 프로퍼티를 갖기 때문에 유사배열 객체이고  for 문으로 순회할 수도 있다.

  ```javascript
  var str = 'string';
  console.log(str[0]); //s
  ```

## 3. 값에 의한 전달

```javascript
var score = 80;
var copy = score; //...(1)

console.log(score); // 80
console.log(copy); // 80

score = 100;

console.log(score); //100
console.log(copy); // ??score의 변경이 copy값에도 영향을 줄까?
```

* (1)번 문이 수행되면, 새로운 숫자값 80을 생성하여 copy에 할당해준다. 이처럼 변수에 원시값을 갖는 변수를 할당하면, 할당받는 변수(copy)에는 할당되는 변수(score)의 원시값이 복사되어 전달한다. -> **값에 의한 전달(pass by value)**

```javascript
var score = 80;
var copy = score;//...(2)

console.log(score, copy); // 80 80
console.log(score === copy); // true

score = 100; //score에 값 재할당
console.log(score, copy); // 100 80
console.log(score === copy); //false ->score의 값을 재할당 해도 copy의 값에는 변화를 주지 않는다.
```

* (2)번 문을 수행하면 score의 값(80)을 복사해서 새로운 메모리 공간에 저장하고  copy에 새로운 메모리 공간(새롭게 복사된 80이 있는 곳)의 주소값을 가리키게 된다.
* 복사가 완료되고 나면 각각 같은 값을 가지고있는 다른 공간을 가리키고 있기 때문에  score에 값을 재할당 하더라도  copy의 값까지 바뀌지 않는다.
* 값에 의한 전달은 값이 변경되더라도 복사된 값에는 영향을 주지 않는다. 객체는 이렇게 동작하지 않는다.
* 값에의한 전달이지만, 엄밀히 말하면 값이 전달되는 것이 아닌 메모리 주소가 전달되는 것이다. 식별자는 메모리공간에 있는 어떤 값을 구별하여 식별해낼 수 있어야 하므로, 식별자가 알아야 하는것은 실제로 저장된 값이 아니라 그 값이 저장된 주소를 알아야 하는 것이다.

* **자바스크립트의 객체**

  : 객체가 생성된 이후에도 동적으로 프로퍼티를 추가할 수도 있고,  delete연산자를 통해서 삭제할 수 있다. 프로퍼티 값에 제약도 없다. 

  원시값과 객체는 근본적으로 다르다. 원시값은 한개의 값만을 다르고, 객체는 여러개의 데이터의 모음인 자료 구조이다.

  원시값은 하나의 값을 다루기 때문에 상대적으로 적은 메모리를 소비한다. 객체는 경우에 따라서 그 크기가 매우 클 수도 있다. (객체의 프로퍼티 값으로 여러가지의 다양한 값들이 올수 있으니까)

  하나의 값만을 다루는 원시값과 비교했을때, 객체는 생성방식과 접근방식이 원시값에 비에서 많은 비용이 든다.

  객체는 원시값과는 다른 방식으로 동작하도록 디자인되어 있다.

* 객체(참조)타입의 값 -> **변경가능한 값이다**. 

  ```javascript
  var person = {
    name: 'kim'
  };
  ```

  원시값을 할당한 경우, 원시값을 할당한 변수가 기억하는 메모리 주소를 통해서 메모리 공간에 접근하면 그 공간안에는 원시 값 자체가 있다. 즉 원시값을 할당한 변수는 원시값 자체를 값으로 갖는다. 그러나 객체를 할당한 변수가 기억하는 메모리 주소를 통해서 그 메모리공간에 접근하면, 참조값이 있다. 참조값은 생성된 객체가 저장되어 있는 메모리 공간의 주소이다.(객체가 있는 공간의 메모리 주소, 객체의 실체가 저장된 곳을 가리킨다.->참조값)

* 원시값을 할당한 변수의 경우, 변수는 ~값을 갖는다, 또는 변수의 값은 ~이다 라고 표현한다. 객체를 할당한 변수의 경우는 "변수는 객체를 참조하고 있다." 또는 "변수는 객체를 가리키고(point) 있다"라고 표현.

* **객체를 할당한 변수는 재할당 없이도 값 자체를 변경할 수 있다.**

```javascript
var person = {
  name: 'kim'
};
person.name = 'kim2'; // 프로퍼티 값 갱신->객체가 변경됨->프로퍼티 키에 접근해서 값을 변경한것, 재할당이 아니다.
person.address = 'seoul'; //프로퍼티 동적 생성
console.log(person); //{name: 'kim2', address: "seoul"}
```

* 원시값에 있는 값을 변경하려면 값을 재할당 해야한다.(새로운 값 생성하여 메모리에 저장) 그러나 객체는 객체를 저장하고 있는 변수의 값을 변경할 때, 재할당이 필요가 없다. 재할당하면 새로운 객체를 생성해야 한다. 객체는 재할당 하지 않고, 기존에 만든 객체를 계속 수정해 나가는 방식으로 값을 변경한다. 
* 객체를 재할당하지 않고 변경하는 이유 -> 객체는 크기가 원시값보다 매우 클 수도 있고, 프로퍼티 값이 객체일 수도 있기 때문에 값이 비싸고 생성하는 비용이 많이 든다고 할 수 있기 때문에 메모리의 효율적 소비도 어렵고, 컴퓨터에도 부담이 크다(low performance). 따라서 객체를 새로 만들지 않고 값을 변경하도록 디자인 되었다.
* 메모리 사용의 효율성과 퍼포먼스를 위한 구조적 단점을 감안한 디자인이다. -> 부작용 : 여러개의 식별자가 하나의 객체를 공유할 수 있다.(프로퍼티값을 변경하거나 추가하면 다른 한쪽도 영향을 받는다. 원시값에는 이러한 영향이 없다.(pass by value))

## 5. 참조에 의한 전달

* 객체는 참조에 의한 전달(pass by reference)로 동작한다.

* ```javascript
  var person = {
    name:'kim'
  };
  var copy= person;//참조 값을 복사
  ```

* 객체를 가리키는 변수(원본  person)를 다른 변수(사본, copy)에 할당하면, 원본의 참조값(주소값)이 복사되어 전달한다. ->참조에 의한 전달->같은 객체를 가리키게 되어 변화가 있으면 두 변수 모두 변하게 된다.

* Quiz

  ```javascript
  var person1 = {
    name: 'lee'
  };
  var person2 = {
    name: 'lee'
  };
  console.log(person1===person2); //false
  console.log(person1.name === person2.name);//true
  ```

  - person1과 person2는 내용은 같지만 별도의 메모리공간에 저장된 객체이므로 false가 나온다. ->내용이 중요한것이 아니고 메모리공간의 주소가 중요

  - 원시값은 다른 메모리공간에 저장되어 있더라도(주소가 다르더라도), 값이 같으면 같다고 본다 -> true.

# 12. 함수

## 1. 함수란?

* 함수는 자바스크립트의 가장 중요한 핵심 개념. 수학에서의 함수: 입력을 받아서 출력을 내보내는 일련의 과정을 정의

  ```javascript
  function add(x,y) {//function 키워드로 함수를 정의.
    return x+y;
  }
  add(2,5); // 7 ->함수 호출을 통해서 add함수가 실행된다. 
  ```

* 프로그래밍의 함수는 일련의 과정을 문들로 구성하고 코드블록으로 감싸 하나의 실행단위로 정의한것이다.

## 2. 함수의 사용이유

* 함수를 사용하지 않으면, 똑같은 모양의 똑같은 행위를 하는 코드를 반복해서 적어줘야 한다. 코드의 반복횟수가 적으면 괜찮겠지만 코드의 반복회수가 100번이 넘어가거나 더 많아진다면 코드를 모두 고쳐주기도 힘들고(수정하는데 비효율적), 계속해서 같은내용을 반복해줘야하는 비생산적인 코드가 된다.
* 함수는 변수처럼 이름을 지정 해줄수 있다. (식별자) 변수이름과 마찬가지로 자신의 역할을 잘 설명해주도록 이름을 지어야 한다. 이는 코드의 가독성측면에서 매우 중요하다.

## 3. 함수 리터럴

* 자바스크립트에서의 함수는 객체 타입의 값이다. 숫자값을 숫자 리터럴로 생성하고, 객체를 객체리터럴로 생성하듯, 함수도 함수 리터럴로 생성할 수 있다. 

  ```javascript
  var add = function add(x,y) {
    return x+y;
  };
  //변수(add)에 함수 리터럴을 할당 
  ```

* 함수 리터럴의 구성요소 : 함수 이름(함수 몸체 내부에서만 참조할 수 있는 식별자, 생략 가능하다.), 매개변수 목록, 함수 몸체(실행단위로 정의한 코드 블록),

* 함수에 이름이 있는함수 = 기명함수, 없는함수=익명함수

* 함수는 객체이지만, 일반객체와는 다르다. 일반객체는 호출할 수 없지만, 함수는 호출할 수 있다. 함수 객체에는 일반객체에는 없는 고유한 프로퍼티를 갖는다. 함수가 객체라는 사실은 자바스크립트의 중요한 특징이다.

## 4. 함수 정의

* 각각의 함수 정의 방식은 미묘하지만 중요한 차이가 있다.

* 1) 함수 선언문

  ```javascript
  function add(x, y) {
    return x + y;
  }
  ```

* 2) 함수 표현식

  ```javascript
  var add = function(x, y) {
    return x + y;
  };
  ```

* 3) function 생성자 함수

  ```javascript
  var add = new Function ('x', 'y', 'return x + y');
  ```

* 4) 화살표 함수 (es6에서 도입)

  ```javascript
  var add = (x,y) => x + y;
  ```

## 5. 함수 선언문

* 함수선언문을 사용하여 함수를 정의하는 방식, 함수이름 생략 불가능하다.->syntax error발생

* 함수선언문은 표현식이 아닌 문이기 때문에 값으로 평가되지 않는다.-> undefined 출력됨.

  ```javascript
  function add(x, y) {
    return x + y;
  }
  
  console.dir(add); // f add(x, y)
  console.log(add(2,5)); // 7 함수 호출
  ```

* 변수에 할당할 수 없다. (표현식이 아닌 문 이니까)

```javascript
var add = function add(x, y) {
  return x + y;
};
console.log(add(2,5)); //7 
//여기에서는 함수 선언문을 변수에 할당 할 수 있는 이유는?
// 자바스크립트 엔진이 상황에 따라서 동일한 함수 리터럴을 표현식이 아닌문인 함수선언문으로 해석하기도 하고, 표현식인 문인 함수 리터럴 표현식으로 해석하는 경우가 있기 때문이다.
```

* ```javascript
  //이름이 있는 함수 리터럴을 단독으로 사용하면 함수 선언문으로 해석한다.
  //함수 선언문은 이름을 생략할 수 없다.
  function foo() { console.log('foo'); } // 
  foo(); // foo
  
  //함수 리터럴을 피연산자로 사용하면 함수 선언문이 아니라 함수 리터럴 표현식으로 해석한다.
  //함수 리터러은 함수 이름을 생략할 수 있다.
  (function bar() { console.log('bar'); });//그룹연산자()내에 있기 때문에 표현식으로 해석한다.
  //자바스크립트 엔진은 그룹연산자 내부를 표현식으로 평가하려고 하기 때문에 값으로 변화시키려고 하므로 함수선언문이 아닌 함수 리터럴로 동작.
  bar(); // referenceError: bar is not defined
  ```

  함수선언문, 함수 리터럴 모두 함수 객체를 생성하지만, 호출에서 차이가 있다.

  함수 선언문으로 정의한 경우에는 함수를 함수 이름으로 호출 할 수 있다(foo();). 함수 리터럴로 선언된 경우는 함수이름으로 호출시 참조에러가 발생한다.(bar();)

  함수 리터럴로 평가된 경우의  bar()는 함수리터럴의 함수 이름은 함수 몸체 내부{...}에서만 호출이 가능하다. 함수몸체 바깥에서는 호출이 불가능하다.

  - 함수선언문으로 해석될 시 -> 함수 이름으로 호출이 가능. 함수 몸체 외부에서도 참조가 가능하다.

* 함수는 함수 이름으로 호출하는 것이 아니라, 함수 객체를 가리키는 식별자로 호출한다. 함수 선언문 방식으로 생성된 함수를 호출한 것은, 함수 이름add가 아닌 자바스크립트 엔진이 암묵적으로 생성한 식별자 add인 것이다.

## 6. 함수 표현식

* 자바스크립트의 함수는 값처럼 변수에 할당할 수도 있고, 프로퍼티 값이 될 수도 있으며, 배열의 요소가 될수도 있다. 이처럼 값의 성질을 갖는 객체를 일급 객체(first-class object)라 한다. 자바스크립트의 함수는 **일급객체**이다. -> 함수를 값처럼 자유롭게 사용할 수 있다는 의미.

* ```javascript
  //함수 표현식 , 개발자가 add라는 식별자명을 명시해주기 때문에 함수에이름이 없어도 된다. 나중에 add로 호출이 가능함.
  //함수의 이름을 적어주는 경우는 함수 몸체 내부에서 함수이름으로 호출할 필요가 있을경우 ,(재귀함수 또는 디버깅을 위해서)
  //그런것이 아니라면 식별자로 함수를 호출하도록 한다.
  var add = function(x, y){
    return x+y;
  };
  console.log(add(2,5)); //7
  ```

* 함수 선언문과 표현식의 차이 -> 내부동작이 동일하지 않고, 함수 선언문은 표현식이 아닌 문이다. 

## 7. 함수 생성 시점과 함수 호이스팅

```javascript
//함수 참조
console.dir(add); //f add(x,y)
console.dir(sub); // undefined

//함수 호출
console.log(add(2,5)); // 7
console.log(sub(2,5)); // typeError: sub is not a function

//함수 선언문
function add(x,y) {
  return x + y;
}

//함수 표현식
var sub = function (x, y){
  return x - y;
};
```

* 함수 선언문인 경우에는, 함수호이스팅을 통해서 선언문 이전에 함수의 호출과 참조가 가능하다. ->함수 선언문은 호이스팅이 발생
* 함수 표현식은 함수 호이스팅이 발생하지 않고 변수 호이스팅이 발생한다. 함수 표현식 이전에 식별자를 참조할 수는 있으나,  undefined가 출력된다. 표현식이 실행된 이후부터 함수호출이 가능하다.
* 런타임 이전에 자바스크립트 엔진이 선언문을 실행한다.

## 8.  function 생성자 함수

* 생성자 함수 : 생성자 함수는 객체를 생성하는 함수를 말한다. 

  ```javascript
  var add = new Function('x', 'y', 'return x + y');
  console.log(add(2,5)); // 7
  ```

* 생성자 함수로 함수를 생성하는 방식은 일반적이지 않고 바람직하지 않다. 이 방식으로 함수를 만들지 않도록 한다. 이러한 방식으로 만들면, 내부 동작이 기존의 함수들과 다르다. ->클로저를 생성하지 않는다.

## 9. 화살표 함수

* es6에서 새롭게 도입된 함수정의 방식. function 키워드 대신 화살표를 사용하여 함수를 선언할 수 있다.

* ```javascript
  const add = (x, y) => x + y;
  console.log(add(2,5)); // 7
  ```

* 함수 선언문과 표현식을 완전히 대체하기 위한것이 아니다. 기존의 함수보다 표현과 동작이 간략화 되어있다. 화살표 함수는 생성자 함수로 사용할 수 없으며, 기존의 함수와 this바인딩 방식도 다르고 프로토타입 프로퍼티가 없으며  arguments객체를 생성하지 않는다.

## 10. 매개변수와 인수

* 함수를 호출 할 때는 함수 객체를 가리키는 식별자로 호출한다. 함수 호출 연산자 내에는 0개 이상의 인수를 쉼표로 구분하여 나열한다.
* 매개변수(parameter, 인자): 함수의 실행을 위해 필요한 값을 함수 외부에서 내부로 전달할 필요가 있는 경우. 인수는 값으로 평가될 수 있는 표현식.
* 매개변수는 함수 몸체 내부에서만 참조 가능하고, 몸체 외부에서는 참조할 수 없다. 매개변수의 스코프(유효범위)는 함수 내부이다.

## 11.  인수 확인

* ```javascript
  function add(x, y){
    if(typeof x !== 'number' || typeof y !== 'number'){
      throw new TypeError('매개변수에 숫자가 아닌 다른 타입이 할당되었습니다.');
    }
    return x + y;
  }
  console.log(add(2)); // typeError: 매개변수에 숫자가 아닌 다른 타입이 할당되었습니다.
  console.log(add('a','b')); //typeError: 매개변수에 숫자가 아닌 다른 타입이 할당되었습니다.
  ```

* 자바스크립트에서는 인수의 타입을 강제할 방법이 없으므로 제대로 적절한 인수가 전달되었는지 확인이 필요하다.



## 12. 매개 변수의 최대 개수

* 자바스크립트 엔진마다 매개변수의 최대 개수에 대한 제한이 있지만, 충분히 많은 매개변수를 지정할 수 있다. 매개변수의 개수가 많아지면 함수를 호출방법이 어려워지기 때문에 실수를 발생시킬 가능성이 높아진다. 매개변수의 개수나 순서가 변경되면 함수의 호출 방법도 변경되므로 함수를 사용하는 코드 전체가 영향을 받는다. ->유지보수성이 나빠짐.
* 매개변수는 최대 3개 이상을 넘지 않도록 권장한다. 매개변수가 많아지면 함수가 여러가지 일을 한다는 증거이므로 바람직하지 않다. 함수몸체는 가급적 짧은 것이 좋다.

## 13. 반환문

* 함수는 return 키워드와 반환값으로 이루어진 반환문을 사용하여 실행 결과를 함수 외부로 반환할 수 있다.

  ```javascript
  function multiply(x, y){
    return x*y; //값의 반환
  }
  var result = multiply(3,5);
  console.log(result); //15
  ```

* ```javascript
  function multiply(x, y){
    return x*y; //값의 반환
    console.log('실행되지 않는다.');//반환문 이후에 다른문이 존재하면 그 문은 실행되지 않고 무시된다.
  }
  console.log(multiply(3,5)); //15
  ```

* return 키워드 뒤에 반환값을 명시적으로 지정하지 않으면  undefined가 반환된다. 반환문은 생략이 가능하다.  return 키워드와 반환값 사이에 개행을 하면 세미콜론이 추가되어 의도치 않은 결과가 발생할 수 있으므로 개행을 하지말자.

## 14. 외부 상태의 변경과 함수형 프로그래밍

* ```javascript
  function changeVal(primitive, obj){
    primitive += 100;
    obj.name = 'kim';
  }
  
  //외부상태
  var num = 100;
  var person = { name: 'lee' };
  
  console.log(num); // 100
  console.log(person); // {name:'lee'}
  
  //원시 값은 값 자체가 복사되어 전달되고 객체는 참조값이 복사되어 전달된다.
  changeVal(num, person);
  //원시 값은 원본이 훼손되지 않는다.
  console.log(num); //100
  //객체는 원본이 훼손된다.
  console.log(person); //{name: 'kim'}
  ```

* 원시값과 객체를 각각 매개변수 primitive와 obj에 전달받음.

* 값에의한 전달을 받은 primitive 매개변수에는 100이라는 값이 새로 할당된다.(값에 의한 전달) (num과 primitive는 서로 영향을 주지않는 전혀다른 값이다.)

* 참조에 의한 전달을 받은 obj매개변수에는 함수외부의 person객체의 주소가 전달된다.(참조에 의한 전달) = person과 동일한 객체를 참조하게 된다.따라서 새로운 프로퍼티 값을 재할당하면 원본 객체인 person의 프로퍼티값에도 변화가 생긴다.

* 이런식으로 코딩하면 코드의 복잡성이 증가한다. 객체의 변경을 추적하는 것은 매우 어렵기 때문. -> 객체를 원시값처럼 사용하여(값에 의한 전달방식) 외부상태의 변경 추적을 수월하게 하도록 한다.

## 15. 즉시 실행 함수

* IIFE(immediately invoked function expression)즉시 실행 함수. 단 한번만 호출되며, 다시 호출할 수 없다. 따라서 즉시 실행 함수는 함수 이름이 없는 익명함수를 사용하는 것이 일반적.

  ```javascript
  //익명 즉시 실행 함수, 함수 리터럴-> 일반적으로 소괄호로 닫아준다.(그룹연산자)
  (function(){
    var a=3;
    var b=5;
    return a*b;
  }());//함수 호출의 의미로 ()를 써준다. 함수를 정의함과 동시에 단한번 호출 됨.
  
  
  //기명 즉시 실행 함수
  (function foo(){
    var a=3;
    var b=5;
    return a*b;
  }());
  foo(); // reference error: foo is not defined ->foo는 함수 이름이고 함수 내부에서만 호출 될 수 있다. 그리고 함수 전체가 그룹연산자로 감싸져 있기 때문에 함수 선언문이 아니라는 것이다;함수 리터럴이다. 함수 선언문이었다면 foo라는 이름으로 함수몸체 외부에서도 선언할 수 있었을 것이다. (자바스크립트 엔진이 암묵적으로 함수 선언문에서는 함수이름을 식별자로 할당하기 때문에)
  //즉시실행함수는 단한번만 호출할 수 있고 재사용이 불가능
  ```

  * 즉시실행 함수는 그룹연산자로 감싸주지 않으면 에러가 발생한다. 그룹연산자의 피연산자는 값으로 평가되므로 함수 선언문이나 함수 표현식을 그룹연산자로 감싸면 함수 리터럴로 평가되어 함수 객체가 된다.

  * 그룹 연산자로 함수를 묶은 이유는 함수를 평가하여 함수 객체를 생성하기 위해서이다. 먼저 함수를 평가해서 함수 객체를 생성할 수 있다면 그룹연산자 이외의 연산자를 사용하여도 무방하다.

    ```javascript
    (function(){
      //...
    }());
    
    (function(){
      //...
    })();
    
    !function(){
      //...
    }();
    
    +function(){
      //...
    }();
    //위의 네가지 모두 사용가능
    ```

    * 즉시 실행 함수도 일반 함수처럼 값을 반환할 수 있고 인수를 전달할 수도 있다.

    ```javascript
    //즉시 실행 함수도 일반 함수처럼 값을 반환할 수 있다.
    var res = (function() {
      var a=3;
      var b=5;
      return a*b;
    }());
    console.log(res); //15
    
    //즉시 실행 함수에도 일반 함수처럼 인수를 전달할 수 있다.
    res=(function (a,b) {
      return a*b;
    }(3,5));
    
    console.log(res); //15
    ```

* 즉시 실행 함수 내에 코드를 모아두면 변수들의 스코프 범위가 좁아지기 때문에 혹시 있을지도 모르는 변수나 함수 이름간의 충돌을 방지할 수 있다.

## 16. 재귀함수(recursive function)

* 함수가 자기 자신을 호출하는 것을 재귀호출이라고 한다. 이러한 함수를 가리켜 재귀함수라고 한다.

* 재귀 호출을 통해 반복 연산을 간단하게 구현할 수 있다. 팩토리얼은 재귀호출로 간단하게 구현할 수 있다.

  ```javascript
  //factorial함수
  function factorial(n) {
    //탈출 조건: n이 1 이하일 때 재귀호출을 멈춤. 더이상 재귀호출을 하지 않는다.
    if(n<=1) return 1;
    //재귀 호출
    return n * factorial(n-1);
  }
  ```

* 주의점: 자기자신을 무한히 호출하기 때문에 반드시 **탈출조건을 작성한다.**

## 17. 중첩함수

* 함수 내부에서 정의된 함수를 중첩함수(nested function) 또는 내부함수(inner function) 라고 한다. 중첩함수를 포함하는 함수는 외부함수(outer function)이라 한다.

```javascript
function outer() {
  var x = 1;
  
  //중첩함수
  function inner() {
    var y = 2;
    //외부 함수의 변수를 참조할 수 있다.
    console.log(x+y); //3
  }
  inner();
}
outer();
```

* if문이나 for문 내에서도 함수를 정의할 수 있으나, 호이스팅이 혼란스러워 질 수 있으므로 함수선언문을 통해서 if 문이나 for 문 내부에 함수를 정의하는 것은 바람직하지 않다.