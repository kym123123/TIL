# 웹 프로토콜

## HTTP(Hyper Text Transfer Protocol) : 하이퍼텍스트 전송 프로토콜

<u>하이퍼미디어</u>(user가 정보를 탐색할때, 어떤 제목에서 관련된 다른 제목으로 뛰어 넘어 갈 수 있도록 연결된 것. 주로 문자정보이면 하이퍼텍스트, 음악, 영상, 애니메이션이면 하이퍼 미디어이다.) 문서를 전송하기 위한 <u>application layer</u>(컴퓨터 네트워크 프로그래밍에서 인터넷 프로토콜 컴퓨터네트워크를 통해 프로세스간의 통신하는 방식을 위해 설계된 계층) 프로토콜.

HTTP는 client가 요청을 생성하기 위해 연결을 열고, 응답을 받을때까지 대기하는 전통적 client-server 모델을 따른다. HTTP는 무상태 프로토콜로 서버와 클라이언트 요청간에 어떠한 상태도 유지하지 않는다. 무상태 프로토콜의 장점은 서버가 여러 요청을 처리하는 동안에 클라이언트의 정보, 상태, 세션 정보를 유지하기 위한 서버의 부하가 없기 때문에, 대용량 애플리케이션에 이상적이다. 또한 통신 중간에 클라이언트 세션이 종료되어도, 서버에서 현재 상태에 대한 정리를 할 필요가 없어서 효율적이다.

다만, 단점으로는 모든 요청간에 자신의 상태를 나타내기위한 추가 정보를 전달해야 하고, 서버가 이 부분을 해석해야 한다는 것이다.

## HTTP를 사용하여 제어 가능한 기능

1. 캐시: HTTP로 문서의 캐싱 방식을 제어 가능. 서버는 캐싱 대상과 기간을 proxy와 client에게 지시 가능하고, client는 이 캐시를 무시하라고 중간 캐시 proxy에게 지시 가능
2. 인증: HTTP를 통해 WWW-Authenticate(en-US) 또는 유사한 헤더를 사용해 제공되거나, HTTP cookies를 이용해 특정 세션 설정이 가능
3. 세션: cookies는 서버의 상태를 요청과 연결하도록 해준다. HTTP 무상태 프로토콜이지만 이를 사용하여 세션을 만들 수 있다. (장바구니기능 등에서 사용가능)



## HTTP 흐름

클라이언트가 서버와 통신할 때, (최종서버 혹은 중간 프록시 이든) 아래의 과정을 수행한다.

1. TCP 연결을 연다: TCP연결 요청(혹은 여러개의 요청)을 보내거나 응답을 받는데 사용된다. 클라이언트는 새 연결을 열거나, 기존 연결을 재사용하거나, 서버에 대한 여러 TCP연결을 열 수 있다.

2. HTTP 메시지를 전송한다. HTTP2 이전의 HTTP 메시지는 읽을 수 있으나, HTTP2 부터는 메시지가 프레임 속으로 캡슐화 되어 직접 읽기가 불가능하나 원칙은 동일하다. (HTTP/2에서는 메세지가 새로운 이진구조인 프레임 안으로 내장되어, 헤더의 압축, 다중화같은 최적화가 가능하다. 메시지의 의미는 변하지 않으며 클라이언트는 HTTP/1.1 요청을 가상으로 재구성한다.)

   * http 메시지는 request와 response의 두가지 형식이 존재한다.
   * 아래는 http request 메시지이다.

   ```http
   GET / HTTP/1.1
   Host: developer.mozilla.org
   Accept-Language: fr
   ```

3. 서버에 의해 전송된 응답을 읽는다.

   * 아래는 http response 메시지이다.

   ```http
   HTTP/1.1 200 OK
   Date: Sat, 09 Oct 2010 14:28:02 GMT
   Server: Apache
   Last-Modified: Tue, 01 Dec 2009 20:18:22 GMT
   ETag: "51142bc1-7449-479b075b2891b"
   Accept-Ranges: bytes
   Content-Length: 29769
   Content-Type: text/html
   
   <!DOCTYPE html... (here comes the 29769 bytes of the requested web page)
   ```

4. 연결을 닫거나 다른 요청을 위해 재사용한다.



## TCP/IP

컴퓨터 또는 네트워크 기기간에 통신을 위한 규칙. 어떠한 방식으로 상대를 찾고, 연결을 시작/종료 할지 등을 결정하는 프로토콜(규칙)이다. 인터넷과 관련된 프로토콜을 모은 것을 TCP/IP라고 한다.

* TCP/IP의 4계층(Layer)

1. 애플리케이션 계층: HTTP 존재 / user에게 제공되는 애플리케이션에서 사용하는 통신의 움직임을 결정한다. TCP/IP에 여러 공통 앱들이 존재하는데, FTP, DNS, HTTP등이 이 계층에 속한다.
2. 트랜스포트 계층: TCP존재/ 애플리케이션 계층에 네트워크로 접속되어있는 2대의 기기사이의 데이터 흐름을 제공. 이 계층에는 TCP(transmission control protocol)과 UDP(user data protocol) 두 가지 프로토콜이 존재.
3. 네트워크 계층: IP존재/ 네트워크 상에서 패킷(전송 data의 최소 단위)의 이동을 위한 경로를 결정한다. (어떠한 라우터, 네트워크 기기를 거쳐 상대 컴퓨터에 패킷을 전송할 것인가의 절차 결장)
4. 링크 계층: 데이터 링크 계층 또는 네트워크 인터페이스 계층이라고도 한다. 네트워크에 접속하는 하드웨어적인 부분을 다룬다.

TCP/IP 통신의 특징은 계층을 순서대로 거쳐 상대와 통신한다. 송신측에서는 애플리케이션 계층에서 시작하여 링크계층으로 나가고, 수신 계층에서는 링크계층부터 시작하여 애플리케이션 계층으로 올라간다. 

송신측 애플리케이션 계층에서 발생한 HTTP 요청 메시지는, 수신측 애플리케이션 계층에 도달하면 서버에서 확인이 가능해진다. 반대의 경우는 수신측에서 HTTP 응답 메시지의 확인이 가능하다.

* TCP(트랜스포트 레이어)의 역할

  : 신뢰성을 보장하는 역할을 한다. 바이트 스트림을 제공하는데, 용량이 큰 데이터를 전송하기 용이하도록 TCP 세그먼트(단위 패킷)으로 작게 분리하여 관리한다.  작게 분해한 이 TCP 세그먼트를 상대에게 전송하고, 전송이 성공했는지 확인한다. 

  Three Way Handshaking을 통하여 확인하는데, 패킷을 전송하고 통신을 끝내는 것이 아니다. 제대로 전송이 되었는지 상대방에게 확인을 하는 것이다. 이때, 'SYN'과 'ACK'라는 TCP 플래그를 사용한다.

  1. 송신측에서 최초에 'SYN'플래그로 상대에게 접속후, 패킷을 보낸다.
  2. 수신측에서 'SYN/ACK'플래그로 송신측에 접속하여, 패킷 수신완료 사실을 전한다.
  3. 송신측에서 'ACK'플래그를 보내고 패킷 교환 완료를 알린다.

  위의 3단계 과정이 Three way handshaking 이며, 이 과정이 완료되지 못하고 통신이 중단되면, TCP가 다시 같은 과정을 반복 시작하여 통신성공을 보장하도록 해준다.

* IP(네트워크 레이어)의 역할

  : 패킷을 상대방에게 전달하는 역할을 한다. 전달하기 까지 여러 경로와 요소들이 필요한데, (IP 주소, MAC주소...) 통신 상대까지 패킷을 전송하는 경로와 중계기를 거쳐서 전달해준다. 목적지까지 중계를 할때, 컴퓨터와 라우터등의 네트워크 기기들은 최초 출발점부터 최종 목적지까지(엔드포인트)의 경로 전체를 파악하고 있지 않다. 자신이 받은시점부터 바로 다음(자신의 목적지)까지의 정보만 알고 있다. 

* DNS(Domain Name System)의 역할

  : 사람은 숫자로된 IP주소보다 문자로된 주소를 더 기억하기 쉽다. 하지만 컴퓨터는 숫자로된 IP주소만을 이해할 수 있다. 따라서 숫자인 ip주소와 문자로된 도메인을 서로 해석해 주기위해서 DNS서비스가 존재한다. DNS는 도메인 ->  IP로의 변환이나, IP -> 도메인으로 변환하는 서비스를 제공해준다.

## 네트워크 계층 레이어를 겨처서 HTTP 메세지가 전달되는 과정

1. 클라이언트가 도메인 주소를 입력한다.

2. DNS가 전달받은 도메인을 IP주소로 변환해준다.

3. 클라이언트는 IP주소를 받고, 웹 서버로 보낼 HTTP 메세지를 작성하기 시작한다. 이때 URI와 Method의 종류, 사용할 HTTP버전정보를 입력한다.

   ```HTTP
   GET / HTTP/1.1 -> request 헤더
   Host: developer.mozilla.org
   Accept-Language: fr
   ```

4. TCP가 전달받은 HTTP request 메세지를 패킷으로 분해하여 전송이 용이하도록 하고, 각 패킷에 일련번호를 부여한다.

5. IP가 목적지까지의 경로를 관리하고, 중계하면서 목적지로 HTTP 메시지를 전달한다.

6. 하드웨어를 거쳐서 수신측의 TCP로 HTTP 메시지 패킷이 수신되고, 이 패킷들을 일련번호를 통해 HTTP request 메세지로 재조립한다.

7. 수신측의 애플리케이션 계층에서 HTTP request 메시지를 확인하고 내용을 처리한다.

8. 이번에는 수신측이 송신측이 되어서 HTTP response 메시지를 전달하는데, 위의 과정을 반복한다.



## URI과 URL

URI: Uniform Resource Identifiers의 약자로, 리소스를 식별할수 있는 식별자이다. 리소스는 식별 가능한 모든것으로, html, image등 다른것과 구별할 수 있는 모든 것이 해당된다. 식별자는 URI스키마를 나타내는 리소스 식별자인데, 스키마는 리소스를 얻기 위한 수단이다. (HTTP가 스키마이다.)

URL는 URI의 서브셋 이지만, 같은 의미로 사용하기도 한다. URL 포맷에는 스키마, 자격정보, 서버주소, 서버포트, 패스(path), 쿼리(query), 프래그먼트 식별자 등이 있다.

path는 계층적 파일 패스라고도 하는데, 리소스를 식별하기 위해 서버에 존재하는 파일의 경로를 설정하는 것이다.

query는 옵션으로, 원하는 리소스의 경로에 임의의 파라미터를 전달하기 위한 동적 쿼리이다.

프래그먼트 식별자는 원하는 리소스 내의 서브 리소스(어떠한 section)을 가리키기 위한 식별자이다. 이것은 옵션이며 #를 붙여 나타낸다.

## HTTP 클라이언트, 서버

: HTTP는 반드시 클라이언트와 서버가 존재한다. 리소스를 요청하는 쪽이 클라이언트가 되고, 리소스를 제공하는 쪽이 서버가 된다. 통신에 따라서 서버와 클라이언트가 바뀔수도 있다. (2대의 컴퓨터로 통신을 한다면)

서버는 무조건 리퀘스트를 받아야 리스폰스를 줄 수 있도록 설계되어있다. 따라서 통신은 무조건 클라이언트로부터 시작된다. 서버는 어느 클라이언트나 리퀘스트를 전송할 수 있도록 되어있으며, 권한이 없는 클라이언트에게도 그에 맞는 리스폰스를 전달해준다. 따라서 서버에 요청은 누구나 보낼수 있으며, 각기 다른 응답을 받는다.

* HTTP는 stateless 프로토콜이다.

HTTP는 상태를 유지하지 않는 프로토콜이다. 따라서 클라이언트 서버간에 통신하는 동안에는 이전의 리퀘스트나 리스폰스를 기억하지 못한다. 과거에는 웹이 단순한 정적웹이 대부분이었기 때문에 괜찮았으나, 웹이 점점 동적으로 진화하면서 stateless로는 처리하기 힘든 일이 많아졌다. 따라서 이를 보조하기 위해 HTTP Cookies가 도입되었고, 이 쿠키가 상태를 관리해줄 수 있도록 해준다.

HTTP는 리퀘스트 경로(request URI)로 리소스를 식별한다. 따라서 HTTP request 메세지는 URI를 포함해야 한다. 또한 이 리소스로 어떠한 일을 서버에게 부여할지를 나타내기 위해서 Method도 기재해야 하며, 이를 해석하기 위한 HTTP 버전도 명시 해준다.



## HTTP 메서드

HTTP 메서드를 이용하여 클라이언트는 어떠한 리소스에 대해서 서버가 자신에게 해줄 일을 전달한다. 자주 사용하는 대표적인 메서드만을 정리하겠습니다.

1. GET : 리퀘스트 URI로 식별한 리소스를 클라이언트에 전달해달라는 요청. 엔티티(바디)를 포함할 수는 있지만 대체로 포함하여 전송하지 않는다.
2. POST: 엔티티(바디)를 서버에 전송하기 위해서 사용한다. 서버는 전송받은 리퀘스트에 따라서 처리한 결과를 응답으로 되돌려준다.
3. PUT: 파일을 전송하기 위한 메서드이다. 리퀘스트에 포함된 엔티티를 리퀘스트 URI가 지정한 곳에 보존하도록 한다 그러나 HTTP/ 1.1의 PUT에는 인증 기능이 없어 보안상의 문제가 있기 떄문에 잘 사용하지 않는다. REST API를 통해서 서버 클라이언트 웹간의 연계된 설계를 사용하는 경우에는 이용하기도 한다.
4. DELETE: 리퀘스트 URI에 있는 리소스의 삭제를 위한 메서드이다. PUT처럼 인증 기능이 없어서 잘 사용되지 않고, 역시 REST API를 통해서는 사용하기도 한다.



## HTTP 접속, 연결

초기의 HTTP에서는 통신 1회마다, TCP에 의해서 연결을 종료해야했다. 텍스트 같은 작은 데이터는 괜찮지만, 여러번 그리고 규모가 큰 여러개의 데이터를 전송해야 하는 경우, 매번 TCP 연결/종료를 수행하는 것이 부하가 증가하고 비효율적인 일이 되어서 지속 연결이 등장했다. 

* 이때의 HTTP 1회 통신과정: TCP 연결 -> HTTP request & response -> TCP 연결 종료 (다른 통신을 위해서 이 과정을 수차례 반복)

HTTP /1.1에서는 지속연결(persistent connections)를 통해서 서버나 클라이언트 어느 한쪽이 연결을 종료하도록 명시하면 종료되고, 그 외에는 연결이 지속되도록 하였다. 이를통해 서버의 부하를 감소시켜주고, 더 빠른 HTTP request & response 통신이 가능해졌다. 

* TCP연결 -> HTTP request & response1 -> HTTP request & response2 -> HTTP request & response3 -> .... -> 종료요청 발생 -> TCP 연결 종료

이러한 지속연결의 단점은, request송신 후, 해당 요청에 대한 response를 클라이언트가 다시 수신해야 다음 요청의 발행이 가능했다. 이러한 단점을 극복하기 위해서 HTTP 파이프라인화(HTTP pipelining)을 하였다. 이로써, 여러 리퀘스트를 병렬적으로 전송하는 것이 가능해졌다. 

* TCP 연결 -> HTTP request 1, 2 동시 전송 -> HTTP response 1, 2 동시 수신 -> 종료요청 -> TCP 연결 종료

파이프 라이닝을 통하여 여러개의 데이터(많으면 많을수록) 속도의 개선이 생겼다.



## HTTP cookies를 통한 상태관리

: HTTP의 무상태 특성을 개선하기 위해서 HTTP cookies가 도입되었다. 쿠키는 request와 response에 같이 전송되어 상태를 파악할 수 있도록 도움을 준다. 

클라이언트에서도 쿠키를 발행할수 있지만, 보통 서버에서 set-cookie라는 헤더필드에 쿠키를 발행하여 클라이언트로 최초 전송해준다. 브라우저는 response에서 쿠키를 확인하고 등록하여, 매 서버로의 통신마다 쿠키를 같이 전송하게 된다. 서버는 쿠키를 발행할때, 언제, 누구에게, 무엇을 전달했는지 기억해둔다. 따라서 요청이 쿠키와 오게되면 어떤 클라이언트인지를 확인할 수 있게된다.