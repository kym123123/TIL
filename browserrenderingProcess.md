# 브라우저의 렌더링 과정

## 빠른 렌더링을 위해서는

가능한 빨리 HTML과 CSS를 브라우저에게 전달해야 한다. DOM과 CSSOM 트리를 생성하기 위해서이다. DOM과 CSSOM은 모두 아래와 같은 단계를 거쳐서 객체모델로 변환된다.

바이트 -> 문자 -> 토큰 -> 노드 -> 객체모델

HTML markup -> DOM(Document Object Model)

CSS markup -> CSSOM(CSS Object Model)

DOM과 CSSOM은 서로 독립적인 데이터 구조이다.

1. 바이트 -> 문자 : 변환단계

   지정된 인코딩(UTF-8)에 따라서 이진바이트 코드는 문자로 변환된다.

2. 문자 -> 토큰: 토큰화 단계

   HTML5에 지정된 고유 토큰으로 변환된다.

3. 토큰 -> Node: 렉싱 단계

   토큰을 해당 속성 규칙을 정의하는 객체로 변환한다.

4. Node -> DOM / CSSOM: DOM생성 단계 혹은 CSSOM 생성단계

   객체를 트리구조화 한다.



## Render Tree

: 브라우저는 DOM과 CSSOM을 결합하여 렌더트리를 형성한다.

 렌더트리에 생성된 각 노드들은 layout 계산에 사용되고, pixel을 화면에 렌더링하는 paint 에 입력된다.

렌더링트리는 페이지를 렌더링하는데 필요한 노드만 포함된다. 레이아웃은 각 객체의 정확한 위치, 크기를 계산하고, 최종단계로 페인트를 하는데, 픽셀을 실제로 화면에 렌더링하는것이다.

* Visibility: hidden과 Display:none의 차이점 

  visibility hidden 프로퍼티는 노드가 레이아웃 공간은 차지하지만 빈 상자로 렌더되는 것이다. 따라서 렌더트리에 포함된다. 그러나 display:none 프로퍼티는 노드가 레이아웃 공간도 차지하지 않고 렌더트리 자체에 포함되지 않는다. 따라서 DOM 에는 존재하지만 렌더트리에는 존재하지 않는다.

렌더트리가 완성되면(노드와, 노드의 계산된 스타일만 계산) layout 단계가 진행된다. 이 단계는 reflow라고도 하는데, 노드의 정확한 위치와 크기를 계산한다. 이 단계에서는 뷰포트 내에서의 각 요소의 정확한 위치와 크기를 캡쳐하는 <u>상자모델</u>이 출력된다. (모든 상대적 측정값이 px로 변환된다. 렌더되는 노드와 그 노드의 기하학적 형태를 파악한다.)

layout단계 이후 각 노드를 px로 변환하는 단계인 paint단계(레스터화)를 거친다.

* 단계를 정리하면 아래와 같다.

* ```
  1. layout 이벤트는 렌더링 트리의 노드들의 위치와 크기를 계산한다.
  2. 완료되면 브라우저가 paint setup및 paint 이벤트를 발생시킨다.
  3. 이후, 렌더링트리를 화면의 pixel로 렌더링한다.
  4. 뷰포트에 노드들이 표시된다.
  ```



## 렌더링 지연 요소

HTML, CSS, JS는 모두 렌더링 지연요소이다. 따라서 빠른 렌더링을 위해서는 JS를 비동기화 하여 DOM 생성을 차단하지 않도록 하고, CSS는 필요한만큼만 최대한 간단하게 유지하여 빨리 DOM생성이 재개될수 있도록 한다. 

HTML파서는 script 태그를 만나면 DOM 생성 프로세스를 중지시키고, JS엔진에 제어 권한을 넘긴다. JS 실행이 완료되면, 중지 시점부터 DOM 생성이 재개된다. 

인라인으로 script를 실행시 DOM생성이 차단되기 때문에, 초기 렌더링이 지연되며 script 태그 내의 DOM과 관련된 코드들로부터 에러가 발생할 수 있다. 

script 태그 내에서 노드의 style을 바꾸는 코드가 있으면, 즉 CSSOM을 수정하는 코드가 있으면, 브라우저가 CSSOM을 구성하기 위해서 CSSOM을 다운, 생성할때 까지 script 실행 및 DOM생성이 지연된다.

* JS 코드의 실행과정 : JS 코드 -> 토큰(토크나이저에 의해 토큰화) -> AST(JS파서에 의해 AST 생성) -> 바이트코드(바이트 코드 생성기에의해 바이트코드화) -> 런타임(인터프리터가 실행시킴)

이러한 JS 태그에 의한 DOM생성을 지연시키기 위해서는 명시적으로 비동기화를 해주는 것이 성능향상에 좋다. 비동기화를 하면, DOM 생성시에 script 태그를 만나도 '나를 먼저 로드할 필요가 없어'라는 의미를 전달해준다.

1. Async : HTML을 파싱하면서 script태그를 만나면 js의 로드가 시작된다. 하지만 로드가 시작되어도 HTML 파싱이 지속된다. 그러나 JS의 로드가 끝나면 바로 JS가 실행되고 DOM 생성이 중단된다. JS의 실행이 종료되면 다시 DOM 생성이 재개되고 이후에 DOMContentLoaded이벤트가 발생하게 된다. 또한 Async는 여러개의 script 태그를 사용하는 경우 태그 삽입 순서에 상관없이 먼저 로드되는 것이 실행되므로 실행순서를 보장해주지 않는다.
2. defer : async처럼 HTML을 파싱하면서 script 태그를 만나도 DOM 생성이 중단되지 않는다. 차이점으로는 JS의 로드가 완료되더라도 DOMContentLoaded이벤트가 발생하기 전까지(즉, DOM이 완성될 때 까지)는 JS가 실행되지 않는다. 또한 script 태그 삽입 순서에 따라서 실행순서를 보장해준다. 따라서  DOM을 조작하는 코드가 있고, 태그 실행순서가 중요하다면 defer를 사용해야 한다.