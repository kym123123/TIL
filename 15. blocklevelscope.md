# 15. let, const와 블록레벨 스코프

## 1. var 키워드로 선언한 변수의 문제점

* 1) 변수 중복 선언 허용

  * var키워드로 선언된 변수는 같은 스코프 내에서 중복 선언을 허용한다. 

    ```javascript
    var x = 1;
    var y = 1;
    //var 키워드로 선언된 변수는 같은스코프내에서 중복 선언이 허용
    //초기화문이 있는 변수 선언문은 자바스크립트 엔진에 의해 var 키워드가 없는것처럼 동작
    var x = 100;
    var y;//초기화문이 없는 변수 선언문은 무시된다.
    console.log(x); // 100
    console.log(y); //1
    ```

  * Var 키워드로 선언한 변수를 중복선언하면, 초기화문(변수 선언, 초기값 할당을 동시에 하는 문) 유무에 따라 다르게 동작 -> 초기화문이 있으면 var키워드가 없는 것처럼 동작하여 새로운 값이 기존 변수의 값에 할당되고, 초기화문이 없으면 변수선언문이 무시된다.

* var키워드로 선언한 변수는 오로지 함수의 코드 블록만을 지역 스코프로 인정한다. 따라서 함수 외부에서 var키워드로 선언한 변수는 코드블록 내에서 선언해도 모두 전역 변수가 된다.(for문이나 if문의 변수 선언문에서 var키워드로 선언한 변수->전역변수)

* 함수레벨 스코프는 전역변수를 남발할 가능성을 높인다. -> 의도치않게 전역변수가 중복 선언되는 경우가 발생.

* var키워드로 변수를 선언하면 변수 호이스팅에 의해 변수 선언문이 스코프의 선두로 끌어 올려진 것처럼 동작. -> 변수 호이스팅에 의해서 var키워드로 선언한 변수는 변수 선언문 이전에 참조할 수 있다. 

## 2. let 키워드

* var키워드의 단점을 보완하기 위해서 es6에서 새로운 변수 선언 키워드인 let과 const를 도입했다.

* let 키워드로 이름이 같은 변수를 중복선언하면 문법에러(syntaxError)가 발생.

  ```javascript
  let bar = 123;
  let bar = 456; //syntaxError : Identifier 'bar' has already been declared
  ```

* let 키워드로 선언한 변수는 모든 코드 블록(함수, if문 , for, while, try/catch 문 등)을 지역 스코프로 인정하는 블록레벨 스코프를 따른다.

  ```javascript
  let foo = 1;//전역변수
  {
    let foo = 2;//지역변수
    let bar = 3;//지역변수
  }
  console.log(foo); // 1
  console.log(bar); //referenceEroor : bar is not defined.
  ```

* let 키워드로 선언한 변수는 변수 호이스팅이 발생하지 않는것 처럼 동작한다. let 키워드로 선언한 변수를 변수선언문 이전에 참조하면 참조 에러가 발생한다.

* var 키워드와는 달리 let 키워드로 선언한 변수는 '선언단계'와 '초기화단계'(undefined 할당하는 단계)가 분리되어 진행된다. 런타임 이전에 자바스크립트 엔진에 의해 암묵적으로 선언단계가 먼저 실행되지만, 초기화 단계는 변수 선언문에 도달했을 때 실행된다. 따라서 초기화 단계가 실행되기 이전에 변수에 접근하려고 하면 참조에러가 발생한다. let 키워드로 선언한 변수는 스코프의 시작 지점부터 초기화 단계 시작지점까지 변수를 참조 할 수 없다. (var키워드는 선언단계와 초기화단계가 한번에 진행되기 때문에 값의 할당이전에도 참조하면 undefined를 출력하는 것)

* 일시적 사각지대(Temporal Dead Zone;TDZ) : 스코프의 시작 지점부터 초기화 시작 지점까지 변수를 참조할 수 없는 구간

* let 키워드로 선언한 변수는 변수 호이스팅이 발생하지 않는 것처럼 보인다. 하지만 let키워드로 선언한 변수도 여전히 호이스팅이 발생하기 때문에 참조에러가 발생한다. 자바스크립트는 es6에서 도입된 let, const를 포함해서 모든 선언을 호이스팅한다. 단 let,const,class를 사용한 선언문은 호이스팅이 발생하지 않는 것처럼 동작.

  ```javascript
  let foo = 1;
  {
    console.log(foo);// referenceError: cannot access 'foo'before initialization
    let foo = 2;//지역변수
  }
  ```

* let, const 키워드로 선언한 전역 변수는, 전역 객체의 프로퍼티가 아니다.

  ```javascript
  let x = 1;
  //let, const 키워드로 선언한 전역변수는 전역 객체 window의 프로퍼티가 아니다.
  console.log(window.x);//undefined
  console.log(x);//1
  ```

## 3. const 키워드

* const 키워드는 상수를 선언하기 위해 사용한다. 하지만 반드시 상수만을 위해 사용하지는 않는다. const 키워드의 특징은 let 키워드와 대부분 동일하다.

* ```javascript
  const foo = 1;//const키워드로 선언한 변수는 반드시 선언과 동시에 초기화해야 한다.
  //그렇지않을경우 문법에러 발생
  //syntaxError: Missing initializer in const declaration.
  ```

* let 키워드로 선언한 변수와 마찬가지로 const키워드도 블록레벨 스코프를 가지며, 변수 호이스팅이 발생하지 않는 것처럼 동작한다.

* const 키워드로 선언한 변수에 원시값을 할당한 경우, 변수값을 변경할 수 없다. (재할당도 불가능)

  (상수는 재할당이 금지된 변수이다. 값을 저장하기 위한 메모리 공간이 필요하므로 변수의 일종)

* 상수는 상태 유지와 가독성, 유지보수의 편의를 위해서 적극적으로 사용해야 한다.

* 일반적으로 상수의 이름은 대문자로 선언해서 상수임을 명확하게 나타낸다. 여러 단어로 이루어진 경우에는 언더스코어로 구분해서 스네이크 케이스로 표현하는 것이 일반적이다.

* Const 키워드와 객체

  * const 키워드로 선언된 변수에 원시값을 할당한 경우 -> 값을 변경할 수 없다.

  * const 키워드로 선언된 변수에 객체를 할당한 경우 -> 값을 변경할 수 있다.

    ```javascript
    const person = {
      name : 'lee'
    };
    
    person.name = 'kim';//객체는 변경 가능한 값이다. 따라서 재할당 없이 변경 가능
    console.log(person); // {name: 'kim'}
    ```

  * const 키워드는 재할당을 금지할 뿐 불변을 의미하지 않는다. -> 새로운 값을 재할당하는것은 불가능하지만, 프로퍼티의 동적생성, 삭제, 프로퍼티 값으 변경을 통해서 객체를 변경하는 것은 가능하다. **이때 객체가 변경되도 변수에 할당된 참조값은 변경되지 않는다.**

## 4. Var vs let vs const

* 변수 선언시, 기본적으로 const 를 사용하고 재할당이 필요한 경우에는 let을 한정해서 사용하는것이 좋다.
* es6를 사용하면 var을 사용하지 않도록 한다.
* 재할당이 필요한 경우에만 한정해서 let키워드를 사용하고 변수의 스코프는 최대한 좁게 만든다.
* 변경이 발생하지 않고 읽기전용으로 사용하는 (재할당 필요 없는 상수) 원시값과 객체에는 const키워드를 사용한다.