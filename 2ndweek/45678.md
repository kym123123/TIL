# 4. 변수

## 1. 변수란?

* 메모리: 여러개의 데이터를 저장할 수 있는 공간을 가지고 있으며, 각 공간(메모리 셀)마다 주소를 가지고 있다. ->메모리 주소
* 컴퓨터가 연산을 하기 위해서는 연산되는 숫자들의 주소를 기억하고 있어야 한다. 연산의 결과 값도 메모리에 저장을 해놓아야 한다.
* 연산을 위한 숫자, 연산의 결과값 등을 재사용하기 위해서는 해당 숫자들이 있는 메모리셀에 접근하기위한 방법이 있어야한다. 이 방법을 제공하는 것이 변수이다.
* 프로그래밍 언어는 기억하고 싶은 값을 메로리에 저장하고, 저장된 값을 읽어들여 재사용 하기 위해 변수라는 메커니즘을 제공한다.
* 변수: 하나의 값을 저장할 수 있는 메모리 공간 자체, 또는 그 메모리 공간을 식별하기 위해 붙인 이름.
* 변수 이름을 통해서 언제든지 원하는 메모리 공간에 접근해서 참조 할수 있다. 

## 2. 변수 선언

* 변수를 생성하는 것이다. Var, let, const 키워드를 통해서 선언한다.
* 키워드: 자바스크립트와 약속한 명령어, 자바스크립트는 var, let, const를 만나면 뒤에오는 이름으로 변수를 생성하라 라고 인식한다.
* 변수 선언문이 실행되면, 빈 메모리 공간을 확보하고 메모리 공간의 주소를 기억하는 변수가 생성된다.
* 변수가 생성되고 값을 할당하지 않아도, undefined라는 값으로 변수값이 초기화 된다.
* var, let 키워드는 선언하고 값을 할당하지 않을경우 undefined로 변수값이 자동으로 초기화된다. const의 경우는 값을 선언하고 어떠한 값으로 초기화 해주지 않으면 error message가 발생한다.
* Var(es5 이전 까지), let,const(es6이후 새롭게 도입)
* var 키워드는 스코프 이슈, 중복선언 이슈가 있다.

## 3. 변수 호이스팅

* 자바스크립트 엔진이 자바스크립트를 실행 할 때, 한줄 한줄 순차적으로 처리하기 이전에 코드내의 선언문들을 먼저 처리하기 때문에, 선언문이 코드의 위로 끌어올려진 것처럼 동작하는 것이다.

* let,const로 선언한 변수들은 호이스팅이 되지 않는 것처럼 동작한다.

* ```javascript
  console.log(score);
  var score;//변수 선언문
  score = 10;//변수 할당문
  ```

* 변수 할당문은 코드가 실행되면 한줄한줄 처리되기 때문에, console.log를 할당문 이전에 입력하면 undefined가 출력된다.

## 4. 값의 할당

* 값의 할당= 변수 할당, 할당연산자(=)의 우측에 값이 오고, 좌측에 변수가 온다.
* 값을 저장하기 위해서, 일정크기의 메모리 공간을 확보한다.(다른프로그램이 해당 공간을 사용할 수 없게 된다.)
* 값의 주소는 변수명이 기억하게 되고, 변수명을 통하여 해당 메모리 공간에 저장되어 있는 값을 참조(재사용)할 수 있다.
* 변수는 암묵적으로 undefined로 값이 초기화(최초로 값을 할당하는 것) 된다.
* 특정한 값을 변수에 넣어주게 되면, undefined가 할당된 메모리 공간이 아닌 새로운 공간을 확보하여 특정한 값을 할당하게 된다.undefined는 원시값(변경불가능한 값)이기 때문에 변경될수 없어서 지우고 새로운 값을 넣어줄 수 없기 때문이다.

## 5. 값의 재할당

```javascript
var score = 80;//변수의 선언과 값의 할당
score = 90;//재할당
```

* var score=80;은 하나의 문이지만, 자바스크립트 엔진은 이를 선언과 할당이라는 두가지 과정으로 인식하여 실행시킨다.

  ```javascript
  var score;
  score=80;//이렇게 인식하고 실행시킴.
  ```

* const 키워드로 선언한 변수(상수)는 재할당을 할 수 없다.

## 6. 식별자

* 어떤 값을 구별해내서 식별할 수 있는 고유한 이름이 식별자이다.
* 메모리의 어떤 값(원하는 값)을 정확하게 가져올 수 있는 이름이다.
* 변수의 이름도 식별자이다. 식별자는 값을 기억하고 있는 것이 아니고, 메모리의 주소를 기억하고 있는 것이다. 이를 통해서 원하는 값에 접근할 수 있도록 한다.
* 따라서 식별자는 메모리공간에 붙인 이름이라고 할 수 있다.
* 함수, 클래스의 이름도 모두 식별자이다. 메모리상에 존재하는 어떠한 값을 식별해 낼수 있는 것이라면 모두 식별자이다.
* 식별자에는 네이밍 규칙이 정해져있다.
  * 1) 식별자는 특수문자를 제외한 문자, 숫자, _, $ 를 포함할 수 있다.
  * 2) 식별자는 특수문자를 제외한 문자, _, $ 로 시작할 수 있지만 숫자로는 시작할 수없다.
  * 3) 예약어(키워드로 사용하기 위해서 미리 확보된 단어들)는 식별자로 사용할 수 없다. Ex) function, var, let...
* 식별자는 직관적으로 무언가를 의미하는지를 알 수 있도록 네이밍 하는것이 좋다. 의미없이 x, y..등을 사용하는 것은 좋지않음. 다른 사람이 보았을 때도 이해할 수 있도록하며, 변수의 존재목적을 쉽게 알수 있도록 의미를 명확히 표현해 준다. -> 좋은 변수명은 코드의 가독성을 높여준다.
* 네이밍 컨벤션
  * 1) 카멜 케이스 : var firstName;
  * 2) 스네이크 케이스 : var first_name;
  * 3) 파스칼 케이스 : var FirstName;
  * 4) 헝가리언 케이스 : var strFirstName; //type + identifier

# 5. 표현식과 문

## 1. 값

* value는 어떤 식(표현식)을 평가한 결과를 말한다. 

* 변수는 하나의 값을 저장하기 위해 확보한 메모리 공간 자체 또는 그 메모리 공간을 식별하기 위해 붙인 이름이다. 따라서 변수에는 값을 할당해야 한다.

* ```javascript
  var sum = 10 + 20;//30
  //변수에는 표현식의 평가값인 30이 할당된다.
  ```

* 결국 값은 실제 메모리에 저장되는 최소 단위라고 할 수 있다.

## 2. 리터럴

* 리터럴은 사람이 이해할 수 있는 문자, 약속된 기호를 사용하여 값을 생성하는 방식이다.

* 숫자 3은 단순히 숫자가 아닌 숫자 리터럴이다. 자바스크립트 엔진은 3이라는 리터럴을 읽고 평가하여 숫자값 3을 생성하게 된다. 값을 평가하기 전에는 3이라는 숫자값이 아닌 리터럴3이다.

* 리터럴은 평가되어 값을 생성하는 문자(literal)로 기술된 코드. 사람이 이해할 수 있는 문자(숫자,알파벳,한글 등) 또는 미리 약속된 기호로 이루어져 있다. 리터럴을 이용하여 다양한 종류의 값을 생성할 수 있다.

* 정수리터럴(100), 부동소수점 리터럴(13.4), 2진수 리터럴(0b010001), 8진수 리터럴(0o101), 16진수 리터럴(0x41), 문자열 리터럴 ('hello'), 불리언 리터럴(true, false), null리터럴(null),

  undefined리터럴(undefined), 객체 리터럴({name: 'lee', age: '19'}), 배열리터럴([1,2,3]), 함수 리터럴(function(){}), 정규표현식 리터럴

* **리터럴이라는 표기법을 사용하면 값이 생성된다.**

* 리터럴을 코드에 기술하면, 자바스크립트 엔진은 코드가 실행되는 시점(런타임)에 리터럴을 해석하고 값을 생성한다. **리터럴은 값을 생성하기 위해 미리 약속한 표기법(notation)이라고 할 수 있다.**

## 3. 표현식

* 표현식(expression)은 값(value)으로 평가(evaluation)될 수 있는 문(statement)이다. 즉 **표현식은 평가되어 값을 생성하는 문이다**. 리터럴도 값으로 평가되기 때문에 표현식이다.

* 값으로 평가 될 수 있으면 표현식이다. 식별자도 값으로 평가 될수 있으므로 리터럴이다. 

* 함수는 호출하면 값으로 평가되기 때문에, 함수호출문은 표현식이다. 

* **표현식이라는 것은 값으로 평가된다는 점이 중요하다.**

  ```javascript
  //리터럴 표현식
  10
  'hello'
  //식별자 표현식(선언이 이미 존재한다 가정)
  sum
  person.name
  arr[1]
  //연산자 표현식
  10+20//30으로 평가되기 때문에 표현식
  sum=10
  sum!==10
  //함수/메소드 호출 표현식(선언이 이미 존재한다 가정)
  square()
  person.getName()
  ```

* 표현식과 표현식이 생성한 값은 동등한 관계, 동치(equivalent)이다. 표현식은 값처럼 사용할 수 있다.

## 4. 문

* **문은 프로그램을 구성하는 기본단위이자 최소 실행단위.**

* 프로그램이라는 것은 문들의 집합으로 이루어진 것이며, 문을 작성하고 순서에 맞게 나열한 것이 프로그램이다.

* 문은 여러 토근(token)으로 구성된다. 토큰은 문법적인 의미를 가지며 문법적으로 더이상 나눌 수 없는 코드의 기본요소를 의미한다.

* ```javascript
  var sum = 1 + 2 ;
  // var, sum , =, 1 , +, 2, ; 모두 하나의 토큰들이다.
  ```

* 문은 명령문이라고도 부르며, 컴퓨터에게 내리는 명령이다. 문이 실행되면 명령이 실행되고 무슨 일인가가 일어난다.(ex.변수선언문이 실행되면, 변수가 선언된다.)

* ```javascript
  //변수선언문
  var x;
  // 표현식 문(할당문)
  x=5;
  //함수 선언문
  function foo(){}
  //조건문
  if(x>1){console.log(x);}
  //반복문
  for(var i = 0; i<2; i++){console.log(i);}
  ```

* 문은 세미콜론으로 끝나야 한다. 0개 이상의 문을 중괄호로 묶은 코드블록{...}의 뒤에는 세미콜론을 붙이지 않는다.

* 자바스크립트엔진에는 세미콜론을 문의 끝이라고 예측되는 지점에  자동으로 붙여주는 asi 기능이 있기 때문에 꼭 붙여야 하는것은 아니다. 하지만 개발자의 예측과 다르게 세미콜론이 붙는 경우가 있기 때문에, 붙이는 것이 좋다.

## 5. 표현식인 문과 표현식이 아닌 문

* 변수 선언문은 값으로 평가될 수 없기에 표현식이 아니다.

  ```javascript
  var x;//변수선언문은 값으로 평가 될 수 없다. 변수에 할당 불가.
  ```

* 표현식과 문을 구별하는방법

  * 표현식인문과 표현식이 아닌문으로 구별한다. 표현식인문은 값으로 평가될 수 있는 문이고, 표현식이 아닌문은 값으로 평가될 수 없는 문이다.

* 변수 할당문은 값으로 평가 될 수 있기에 표현식이다. 따라서 할당문은 변수에 할당할 수 있다.

  ```javascript
  var foo = x =100;// 변수 할당문은 100으로 평가 될 수 있기때문에 foo라는 변수에 할당이 될 수 있다.
  ```

* 조건문도 값으로 표현될 수 없기에 표현식이 아니고 변수에 할당될 수 없다.

* 표현식인 문을 실행하면 평가된 값을 반환시킨다. 표현식이 아닌문은 undefined를 반환한다.

# 6. 데이터 타입

## 1. 숫자 타입

* 자바스크립트는 원시타입과 객체타입으로 분류할 수 있다.

* 원시타입(primitive type) : 숫자, 문자열, 불리언, undefined, null, symbol - > 변경할 수 없는 값. immutable value

* 객체타입(object/reference type) : 객체, 함수, 배열 등.

  ->	변경할 수 있는값. mutable value

* 1을 숫자로 선언할 수 있고, 문자로 선언할 수 있다. 숫자타입과 문자열 타입은 확보해야 할 메로리 공간의 크기도 다르고 읽어들여 해석하는 방식도 다르다. 저장되는 2진수도 다르다.

* 값을 생성한 목적과 용도도 다르다. 

* 숫자타입=산술연산을 위해서 생성.  문자타입 = 텍스트를 화면에 출력하기 위해서 생성.

* 자바스크립트는 숫자타입이 단 한가지 종류한다. 실수도 정수도 하나의 타입으로 배정밀도 64비트 부동소수점 형식의 2진수로 저장된다. 여러 진수의 수를 표현하기 위한 데이터 타입의 제공이 없기에, 이들 값을 참조하면 모두 10진수로 해석된다.
* 변수에 값이 할당되는 시점에, 값에 의해서 변수의 타입이 결정된다.
*  infinity, -infinity, NaN(not a number)은 모두 숫자타입이다.

## 2. 문자열 타입

* 문자열은 텍스트 데이터를 나타내는데 사용. 한글자는 16bit(2byte)를 소비한다.

* 전세계 대부분의 문자를 표현할 수 있다. 작은따옴표(''),큰 따옴표(""), 백틱(``)안에 텍스트를 넣어 생성한다.

* 일반적으로 문자열을 만들기 위해서 작은따옴표를 사용한다.

* 작은따옴표로 감싼 문자열 내의 큰따옴표는 문자열로 인식된다.

* 큰 따옴표로 감싼 문자열 내의 작은따옴표는 문자열로 인식된다.

* 작은따옴표로 감싼 문자열 내에 또다시 작은따옴표로 감싼 문자열은 에러를 발생시킨다. syntaxError: unexpected identifier

* 작은따옴표로 다시 감싸주고싶다면 아래와같이 백슬래쉬로 같이 감싸준다.

  ```javascript
  var str = '작은따옴표로 감싼 \'문자열내에 다시 작은따옴표로\' 감싸기';
  ```

* 따옴표로 문자열을 감싸주지 않으면 문자열의 시작과 끝을 알기 어렵고, 식별자와 혼동하기 쉽다.

* ```javascript
  var string = hello;//따옴표로 감싸지 않아서 hello를 식별자로 인식하고 엔진이 hello식별자를 찾기 시작하게 된다.
  ```

* 따옴표로 감싸지 않는다면 스페이스같은 공백을 포함시킬 수 없는 문제도 생긴다.

## 3. 템플릿 리터럴

* es6부터 새롭게 도입된 방법으로 백틱(``)을 이용하여 감싸는 방법이다.

* 일반 문자열 내에서는 줄바꿈을 허용하지 않는다. 템플릿 리터럴 내에서는 줄바꿈이 허용된다.

* 이전까지는 이스케이프 시퀀스를 이용하여 줄바꿈을 해주었다.

* 이스케이프 시퀀스 (ex. '\n'은 줄바꿈, '\t'은 탭..등등)을 사용하지 않으면 es5에서는 문자열 내에서 엔터키를 사용해서 인위적인 개행을 해 줄수 없었다.

* ```javascript
  var template = `<ul>
  	<li>home</li>
  </ul>`; //템플릿 리터럴은 개행이 그대로 문자열로 취급되어 보여진다.
  ```

* 표현식 삽입-> 문자열은 문자열 연산자(+)를 사용하여 연결할 수 있다. + 연산자는 피연산자 중 하나이상이 문자열일 경우, 문자열 연결 연산자로 동작한다.

* ```javascript
  var first = 'yongmin';
  var last = 'kim';
  console.log('my name is' + first + ' ' + last);//es5방식의 문자열 연결
  ```

* ```javascript
  console.log(`my name is ${first} ${last}.`); //es6이후의 표현식 삽입방식.
  ```

* 표현식 삽입은 표현식의 평가 결과가 문자열이 아니더라도 강제 타입 변환되어 삽입된다.

  ```javascript 
  console.log(`1+2=${1+2}`);//1+2=3으로 출력
  ```

## 4. 불리언 타입

* 불리언 타입은 논리적 참(true), 거짓(false)를 나타낸다.
* 프로그램의 흐름을 제어하는 조건문에서 자주 사용된다.

## 5. Undefined 타입

* 선언이후에 명시적으로 값을 할당하지 않은 변수는, 자바스크립트 엔진에 의해서 암묵적으로 초기화되는데, undefined값을 갖게된다.
* 주 목적은, 선언하였지만 초기화 하지않은 변수에 자바스크립트 엔진이 암묵적으로 값을 할당해주기 위함이다. 개발자가 인위적으로 이 값을 변수에 넣어줄 일은 없다. 이는 혼란을 가중시킨다.
* 우리가 어떠한 값을 참조하였을때, undefined를 출력받는다면 이 값에는 아무것도 할당해주지 않았다고 생각하기 때문에, 인위적으로 할당해주면 다른 개발자들의 혼란이 커진다.
* 변수에 값이 없다고 얘기해주고 싶은 경우에는 null을 할당해주도록 한다.

## 6. null 타입

* null type은 null이 유일하다. 대소문자를 구분하기때문에 null이라고 기입한다.
* 어떤 변수를 참조하였을때, null이 나오면 개발자가 의도적으로 값이 없다는것을 명시하려 한것을 알 수 있다.
* 함수가 반환할 값이 없을경우에는 null을 반환하기도 한다.

## 7.symbol타입

* es6에 새롭게 추가된 변경불가능한 원시타입이다.

* 이 값은 리터럴이 존재하지 않고 반드시 symbol함수를 통해서 생성한다.

* ```javascript
  var key = Symbol('key');//심볼값 생성함수
  ```

## 8. 객체타입

* 원시타입이 아닌 모든것들을 객체타입이라고 부른다.
* 자바스크립트는 객체기반의 언어로, 거의 대부분이 객체로 이루어져 있다. 다른장에서 집중적으로 다룰것,,,

## 9. 데이터 타입의 존재 이유

* 자바스크립트 엔진은 데이터타입, 값의 종류에 따라 정해진 크기의 메모리 공간을 확보한다. 변수에 할당되는 값의 데이터 타입에 따라서 확보해야할 메모리 공간의 크기가 결정된다.

* 값을 참조할 때, 몇 바이트를 한번에 읽어들여야 할지 결정해야 한다. 8바이트짜리 데이터를 4바이트만 읽어들인다면, 데이터가 훼손되어서 보여진다.

* 값을 데이터 타입에 의해서 잘 저장하고 잘 읽어들일수 있게 한다.메모리에서 읽어들인 2진수를 어떻게 해석해야 하는지에 대한 문제가 남아있다. ->2진수는 어떻게 해석하는지에 따라서 전혀 다른값이 된다. 

* ex> 01000001을 숫자로 해석하면 65이지만, 문자열로 해석하면 

  'A'이다. **저장되어있는 2진수의 해석방법을 알아야 원하는 데이터를 출력할 수 있다. 이러한 해석방법을 제공하는 것이 데이터 타입이다.**

* 데이터 타입이 없다면, 메모리에 저장할 때, 얼마만큼의 메모리 공간을 확보해야 하는지, 데이터를 참조할 때 몇 바이트 단위로 읽어들여야 하는지, 메모리에 저장된 2진수 값을 어떻게 해석해야 하는지도 알 수 없게 된다.

* 1) 값을 저장할 때 확보해야 하는 메모리 공간의 크기를 결정

* 2) 값을 참조할 때 한번에 읽어 들여야 할 메모리 공간의 크기를 결정하기 위해

* 3) 메모리에서 읽어들인 2진수를 어떻게 해석할 지를 결정하기 위해

## 10. 동적 타이핑

* 자바스크립트의 모든 값은 데이터 타입을 갖는다.

* 정적타입 언어는 변수 선언시 데이터 타입을 명시해야 한다.

* 정적타입 언어는 변수의 타입의 변경이 불가하며, 타입체크를 통과하지 못하면 에러가 발생하며 프로그램 실행이 막힌다.

* 이렇게 일관성을 강제하여 안정적인 코드를 구현시킨다.

* 자바스크립트는 동적타입 언어로써, 변수선언시 데이터 타입을 선언하지 않고 var 키워드를 이용한다.

* typeof 연산자로 데이터 타입을 조사할 수 있다.

* null은 typeof 로 데이터 타입을 조사하면 object가 출력된다.(주의)

* 변수의 타입이 있을까? -> typeof로 변수의 타입을 출력시키면 나오는 값은 변수의 타입이 아니라, 변수에 현재 할당되어 있는 값의 타입을 반환하는 것이다.

* 자바스크립트는 어떤 타입의 값이라도 자유롭게 할당이 가능하다. 정적언어와는 다른 데이터 타입의 개념을 가지고 있다. 값을 할당하는 시점에 변수의 타입이 동적으로 결정되며, 변수의 타입은 고정되어 있지 않고, 재할당 되는 값에 의해서 언제든지 동적으로 변할수 있다.

* 따라서, **기본적으로 변수는 타입을 갖지 않는다.(var) 하지만 값은 명확히 타입을 가지고 있다. 값의 타입에 따라서 변수의 타입이 동적으로 변경되는 것이다.**

* 이러한 편리한 변수타입 변경 가능성은 이점도 있지만 단점도 있다. 현재 변수내의 값을 추적하기에 어려울 때가 있다. 정적타입 언어는 한번 선언한 타입이 변하지 않기에, 이로인해서 곤란할 일이 없지만 자바스크립트에서는 변수의 타입이 값의 타입에 의해서 변하기 때문에, 변수내의 값에 정확히 이해가 없다면 이를 잘못 예측하여 오류를 발생시키기 쉽다. 

  (편리성 high, 신뢰성 low->trade-off)

* 모던 자바스크립트에서는 타입을 가지고있는 타입스크립트를 많이 사용하기도 한다.

* 변수를 사용하지 않을 수 없지만, 되도록이면 변수의 사용을 적극적으로 줄여서 오류 발생 가능성을 낮추자.

* 전역변수(어디에서든 참조할 수 있는 변수)의 사용을 금하자.

* 변수의 생명주기(스코프)를 최대한 짧게 만들도록 한다.

* 변수의 값이 변하는 경우가 아니라면, 변수보다는 상수를 사용하여 값의 변경을 억제하는 것이 좋다. **const** 키워드를 사용하면 상수 선언이 가능하다.

* 변수를 이름지을 경우, 변수의 존재 이유를 파악할 수 있도록 명명한다. -> 오해를 불러일으키거나 실수를 야기할 가능성이 낮아진다.

# 7. 연산자

## 1,2 . 이항 산술 연산자 & 단항 산술 연산자

* **연산자는 하나 이상의 표현식(피연산자)을 대상**으로 산술, 할당, 비교, 논리, 타입, 지수연산 등을 수행해 하나의 값을 만든다.

* 연산자 표현식(피연산자+연산자)도 값으로 평가되어지는 표현식이 된다.

* 피 연산자가 값이라는 명사의 역할을 한다면, 연산자는 피연산자를 연산하여 새로운 값을 만든다 라는 동사의 역할을 한다.

* 1) 산술 연산자 : 피연산자를 대상으로 수학적 계산을 수행해 새로운 숫자 값을 만듬. 연산이 불가능한 경우 NaN을 반환한다. -> NaN은 숫자타입의 값이다.

  ​	산술연산자는 피연산자의 개수에 따라서, 이항산술 연산자와 단항산술 연산자로 구분된다.

  ​	 (1) 이항산술 연산자 : +,-,*,/,%

  ​	 (2) 단항산술 연산자 : 피연산자가 1개인 연산자. 

  ​		++, --,  +,  -(부호 반전)

  ​		`++와 --는 변수의 앞 뒤에 붙는 차이로 할당후 증감, 		할당	전 증감이 결정된다.`

  ​		`+뒤에 문자가 오면 ex>+'10' , 문자열이 숫자로 타입변환된다.단, 피연산자인 '10'을 직접수정이 아니고 숫자값으로 변형을 해서 새로운숫자를 만드는것이다. 직접 변하는 것은 아니다.`

* ```javascript
  var x='10';
  console.log(+x); //숫자10 출력
  console.log(typeof +x); // number출력
  //x에 할당된 문자열 10 자체가 숫자 10이 된 것은 아니다!!! 변함없이 string이다. ->부수효과 없다.(x에 할당된 변수값을 재할당해서 변경하지 않는다.)
  ```

* ```javascript
  var y = 1;
  console.log(++y); //2
  console.log(y);// 2 
  //++연산자를 이용하면 y의 값 자체를 재할당시킨다.
  ```

* 대부분의 연산자들은 부수효과가 없다. 그러나 세 가지 부수효과를 가진 피연산자가 있다.

```javascript
-(-10); // 10 부호를 반전
-'10'; // -10 문자열을 숫자로 타입 변환
-true; // -1 불리언 값을 숫자로 타입변환
-'hello'; // NaN 문자열을 숫자로 변환시킬 수 없음.
//모두 부수효과는 없다.
```

## 3. 문자열 연결 연산자

* 연산자는 피연산자 중 하나 이상이 문자열인 경우, 문자열 연결 연산자로 동작한다.

* ```javascript
  1 + true; // 2 true는 1로 타입변환
  1 + false; // 1 false는 0으로 타입변환
  1 + null; // 1 null은 0으로 타입변환
  +undefined; //NaN  undefined는 숫자로 변환x
  1 + undefined; //NaN
  ```

* 이처럼 자바스크립트 엔진은 *암묵적 타입변환* 또는 타입 강제변환이 빈번하게 일어난다.

## 4. 할당 연산자

* 할당연산자는 우항에 있는 피연산자의 평가 결과를 좌항에 있는 변수에 할당한다.

  | 할당 연산자 | 사례  | 동일표현 | 부수효과 |
  | ----------- | ----- | -------- | -------- |
  | =           | x = 5 | x = 5    | O        |
  | +=          | x+=5  | x=x+5    | O        |
  | -=          | x-=5  | x=x-5    | O        |
  | *=          | x*=5  | x=x*5    | O        |
  | /=          | x/=5  | x=x/5    | O        |
  | %=          | x%=5  | x=x%5    | O        |

* 할당연산자는 변수에 재할당이 이루어 지기 때문에 부수효과가 존재한다.

## 5. 비교 연산자

* 좌항과 우항의 피연산자를 비교한 다음 그 결과 불리언 값을 반환한다.

* 동등/일치 비교연산자

  | ==   | 동등비교   | x==y  | x와 y의 값이 같다.          | 부수효과 x |
  | ---- | ---------- | ----- | --------------------------- | ---------- |
  | ===  | 일치비교   | x===y | x와 y의 값과 타입이 같다.   | 부수효과x  |
  | !=   | 부동등비교 | x!=y  | x와 y의 값이 다르다.        | 부수효과x  |
  | !==  | 불일치비교 | x!==y | x와 y의 값과 타입이 다르다. | 부수효과x  |

  * 동등비교연산자를 사용하면, 암묵적 타입변환이 일어나서 같은 타입으로 맞춰진 후 비교 된다.

  * 동등비교 연산자는 결과를 예측하기 어렵다. 결과예측이 곤란하기 때문에, 동등비교 연산자를 사용하지 않고 일치비교 연산자를 사용하도록 하자.

* 일치비교 연산자를 사용하는 경우에는 NaN사용시 주의해야한다.

* ```javascript
  NaN === NaN;//false, nan은 자기자신과 일치하지 않는 유일한 값이다.
  ```

* isNaN();함수를 이용해서 NaN인지 아닌지 조사하도록 하자.

* +0과 -0도 일치비교시 같다고 판단되기 때문에, +0과 -0을 엄격히 판단해야 할 경우에는 Object.is(-0,+0);을 사용한다.

## 6. 삼항 조건 연산자

* 피연산자가 3개이다.

* ```javascript
  var result = x % 2 ? '홀수':'짝수'; 
  //조건식이 참 일 경우, 홀수가 반환, 거짓일경우 짝수가 반환된다.
  ```

## 7. 논리 연산자

* || : OR의 의미를 갖고있다.

* && : AND의 의미를 갖고있다.

* ! (논리부정 연산자) :반대의 논리연산을 한다.

* 단축평가 : 'cat' && 'dog'; //dog로 출력된다. 'cat'은 true로 평가되기 때문에 dog에 의하여 결과값이 결정되기 때문이다. 뒤에서 자세히 다룬다.

* 쉼표연산자 : 왼쪽 피연산자 부터 차례대로 피연산자를 실행, 평가하고 마지막 피연산자의 평가가 끝나면 마지막 피연산자의 평과결과를 반환한다.

  ```javascript
  var x,y,z;
  x = 1, y = 2, z = 3; //3
  ```

* 그룹 연산자: 피연산자인 표현식을 가장 먼저 평가한다.()를 이용하여 감싸면 연산자의 우선순위를 조절 할 수 있다. ()안의 내용이 더 우선적으로 연산되도록 한다. 

## 8. typeof 연산자

* 피연산자의 데이터 타입을 문자열로 반환한다.
* null을 반환하는 경우는 없으며, 함수의 경우에는 object가 아닌 function을 반환한다. null은 object를 반환하는데, 이는 자바스크립트의 버그이다.

## 9. 지수 연산자

* 좌항의 피연산자를 밑으로, 우항의 피연산자를 지수로 거듭 제곱하여 숫자 타입의 값을 반환한다.

* ```javascript
  2 ** 2;//4
  2 ** 2.5; // 5.656854....
  2 ** 0; //1
  2 ** -2; // 0.25
  -5 ** 2;// 문법에러
  (-5) **2; //25 ->음수는 반드시 괄호로 묶어줘야한다.
  ```

* 지수 연산자가 도입되기 이전에는 Math.pow메소드를 사용하였다.
* Math.pow(2,2); -> 4 >>>가독성이 지수연산자보다 떨어지며, 여러 제곱의 관계가 나오면 가독성이 매우 떨어진다.
* 지수연산자는 모든 이항 연산자보다 우선 순위가 높다.

# 8. 제어문

* 주어진 조건에 따라서 코드 블록을 실행하거나 반복 실행할 때 사용한다. 일반적으로 코드는 위에서 아래로 순차적으로 실행된다. 제어문을 사용하면 코드의 실행 흐름을 인위적으로 제어할 수 있다.
* 코드의 실행 순서가 변경되면, 단순하게 위->아래로 순차적으로 진행하는 직관적 코드흐름을 혼란스럽게 한다.
* 제어문은 코드의 흐름을 이해하기 어렵게 만들어서 가독성을 해치는 단점이 있다.
* 고차함수를 사용한 함수형 프로그래밍에서는 제어문의 사용을 억제하여 복잡성을 해결하려고 노력한다.

## 1. 블록문

* 코드블록: 여러개의 문을 하나의 실행단위로 그룹화 한다.
* 블록문(코드블록): 0개 이상의 문을 중괄호로 묶은 것으로 코드블록/블록 이라고 부른다.
* 단독으로 블록문을 사용할 수도 있으나, 제어문이나 함수 선언문에서 사용하는 것이 일반적이다. ;을 붙이는것이 일반적이지만, 블록문의 끝에는 ;을 붙이지 않는다.

## 2. 조건문

* 주어진 조건식의 평과 결과에 따라서 코드블럭의 실행을 결정한다. 조건식은 불리언값으로 평가될 수 있는 표현식이다.

* If...else문과 switch문을 제공한다.

* If...else문

  * if라는 키워드를 사용하고 조건식과 else를 동반한다.
  * if(조건식)에서 조건식이 0 또는 1이 주어진다면, 자바스크립트 엔진에서 암묵적으로 타입변환을 실행하여 불리언 값으로 형변환 시킨다.
  * 조건식은 한 개 이상일 수  있다. 2번째 조건부터 else if(조건식2...)로 표기해준다. ->여러개의 조건을 줄 수 있다.

* 코드 블록 내의 문이 하나뿐이라면, 중괄호를 생략할 수 있다.

  ex> if(조건) return a;

## 3. switch 문

```javascript
switch(표현식){
  case 표현식1:
    switch 문의 표현식과 표현식1이 일치하면 실행될 문;
    break;  
  case 표현식2:
  	switch 문의 표현식과 표현식2가 일치하면 실행될 문;
    break;
  default:
  	switch 문의 표현식과 일치하는 표현식을 갖는 case문이 없을 때 실행될 문;    
}
```

* switch문의 표현식은 값보다는 문자열, 숫자 값인 경우가 더 많다. 반드시 불리언 값이어야 할 필요가 없다. 
* 논리적인 참, 거짓보다는 다양한 case에 따라 실행할 코드 블록을 결정할 경우 사용한다. 
* fall through : 표현식이 자신과 일치하는 case 표현식n을 찾아서 실행되고 나면, 그뒤에 있는 case들을 모두 실행시키는 현상이다. 따라서 이를 방지하기 위해서 case마다 break키워드를 추가하여 방지해준다.
* Break->제어문의 코드블록을 탈출 할 수 있도록 한다.
* default문은 가장 마지막에 써주고, 가장 마지막이기 때문에 폴스루 현상이 발생하지 않아서 break문이 필요가 없다.
* switch 문은 if..else문 보다 복잡하다. 따라서 되도록이면 if..else문으로 해결할 수 있는경우라면 if..else문을 사용하도록 하자.

## 4. 반복문 (for문, while문, do-while문, for in, for of문..forEach문)

* ```javascript
  //for문
  for(var i =0; i<2; i++){//변수선언/할당문,조건식,증감문 ->조건식이 false가 될때까지 반복실행
    console.log(i); //0 1
  }
  ```

* ```javascript
  //while문
  var count = 0;
  while(count < 3){
    console.log(count);
    count++;
  }//0 1 2
  ```

* 조건식의 평가 결과가 참이면 코드블록을 계속해서 반복 실행한다. 조건문의 평가 결과가 거짓이 되면 실행을 종료한다.

* 증감문이 없다면 무한루프에 빠지게 된다.

* 조건식 while(true)를 써주면 무한대로 돌아가게 되므로 탈출 조건을 if, break를 사용하여 만들어 준다.

* ```javascript
  var count = 0;
  do{
    console.log(count);
    count++;
  }while(count <3 );
  //do while문은 코드블록이 최소 한번은 실행된후에 조건식을 판단하여 계속할지 멈출지 결정된다.
  ```

## 5. break문

* 코드 블록을 탈출한다. 레이블문, 반복문, switch문의 코드 반복을 멈추고 나갈 수 있게해준다.

* 레이블 문(label statement) : 식별자가 붙은 문이다,

  ``` javascript
  foo: console.log('foo');
  //foo라는 레이블 식별자가 붙은 레이블 문
  ```

  ```javascript
  foo: {//foo라는 식별자가 붙은 레이블 블록문
    console.log(1);
    break foo;//foo레이블 블록문을 탈출한다.
    console.log(2);
  }
  console.log('Done!');
  ```

## 6.continue 문

* 코드블록 실행을 현지점에서 중단하고 반복문의 증감식으로 이동한다. break문과는 다르게 반복문 자체를 탈출하지는 않는다.

# 9.타입 변환과 단축 평가

## 1. 타입변환이란?

* 개발자가 의도적으로 값의 타입을 변환하는 것을 명시적 **타입변환(Explicit coercion)** 또는 **타입캐스팅(Type casting)**이라 한다.

* ```javascript
  var x = 10;
  var str = x.toString(); //문자열로 타입을 변환
  console.log(typeof str, str);//string 10
  ```

* 주의점: x에 있던 숫자값이 변경된 것은 아니다. 새로운 문자열 값을 만든것이지, 숫자값 10을 직접 변경한 것은 아니다.

* 암묵적 타입변환(Implicit coercion) : 개발자의 의도와는 상관없이 표현식을 평가하는 도중에 자바스크립트 엔진에 의해 암묵적으로 타입이 자동변환 되는 것 = 타입강제변환(type coercion)

* ```javascript
  var x = 10;
  var str = x + '';//숫자값 10을 이용해서 문자열 '10'을 생성하게 된다.
  console.log(typeof str, str);
  //타입변환이란 기존 원시값을 사용해, 다른 타입의 새로운 원시값을 생성하는 것이다.
  ```

* 명시적 타입 변환은 개발자의 의지가 코드에 드러나기 때문에 가독성이 좋지만, 암묵적 타입변환은 코드에 드러나지 않기때문에 예측을 하지 못한다면 오류를 생산할 가능성이 높아진다.

* 그러나 경우에 따라서는 암묵적 타입변환이 가독성이 더 좋을 수 있다.

  ```javascript
  (10).toString()//명시적
  10 + ''//암묵적
  //이 경우에는 암묵적 타입변환이 더 간결하고 가독성 측면에서 이해하기 쉽다.
  ```

  ## 2. 암묵적 타입변환

  * 자바스크립트 엔진이 표현식을 평가 할 때, 개발자의 의도와는 상관없이 코드의 문맥을 고려하여 암묵적으로 데이터 타입을 강제변환

  * ```javascript
    '10' + 2 //'102'
    5 * '10' // 50
    1 - '1'//0(숫자)
    
    //피연산자 또는 표현식이 불리언 타입이어야 하는 문맥
    !0 //true
    if(1){ }//if문의 조건식의 자리에 0 또는 1이 올경우 false 와 true로 암묵적 타입변환을 실시
    ```

  * 이처럼 표현식을 평가할 때, 가급적으로 에러를 발생시키지 않도록 암묵적 타입변환을 통해 표현식을 평가한다.

  * ```javascript
    console.log(`1+1 = ${1+1}`); //"1+1 = 2"
    //템플릿 리터럴에서 ${}내의 숫자 1+1은 문자열2로 암묵적 타입변환된다.
    ```

  * es6에서 새롭게 도입된 심볼타입에서는 암묵적 타입변환이 실행되지 않는다.

  * ```javascript
    //단항연산자를 이용한 타입변환
    +'' // 0
    +'0' // 0
    +'1' // 1
    +'string' //NaN
    +true //1
    +false //0
    +null //0
    +undefined // NaN
    ```

  * ```javascript
    if ('') console.log('1');
    if (true) console.log('2');
    if (0) console.log('3');
    if ('str') console.log('4');
    if (null) console.log('5');
    // 2 4 ->Truthy 와 Falsy에 의해서 나온 결과이다.
    ```

  * Truthy와 Falsy

    False, undefined, null, 0, -0, NaN, ''(빈 문자열) -> 이 값들 이외의 것들은 모두 Truthy이다.

##   3. 명시적 타입 변환

* 개발자의 의도에 의해서 타입을 변경. 
* 암묵적 타입변환을 이용하여 명시적 타입변환을 하는 방법도 있다.
* String()을 이용하여 문자열로 타입변환 해줄 수 있다.
* x.toString()을 이용하여 문자열로 타입변환 해줄 수 있다.
* 1 + ''을 이용하여 문자열로 타입변환 해줄 수 있다. (암묵적 타입변환을 명시적변환으로 이용)
* parseInt(정수로 변환), parseFloat(실수로 변환, 소수점 포함) 함수는 문자열만 숫자타입으로 변환 가능하다.
* Number()을 이용하면 문자열을 숫자타입으로 변환 가능하다.
* 문자열앞에 +를 붙여주거나 1을 곱해주면 문자열을 숫자로 간편하게 변환할 수 있다.

## 4. 단축평가

* 논리합( || ), 논리곱( && )연산자 표현식의 평가 결과는 불리언 값이 아닐 수도 있다. 논리합, 논리곱 연산자 표현식은 언제나 2개의 피연산자 중 어느 한쪽으로 평가된다.

* ```javascript
  'cat' && 'dog'// 'dog'
  //cat은 truthy값이므로 true로 평가되기 때문에, 이 표현식의 결과는 뒤의 'dog'에 의해서 결정지어 지므로 'dog'를 반환한다.
  //앞에 falsy가 온다면 falsy값을 바로 반환한다.
  ```

* 논리합 연산자는 두개의 피연산자 중 하나만 true로 평가되어도 true를 반환한다.

  ```javascript
  'cat' || 'dog' //'cat' -> 앞의 truthy값만으로 값의 평가가 가능하기 때문에 'cat'을 반환한다.
  ```

* **단축평가는 표현식을 평가하는 도중에 평가 결과가 확정된 경우, 나머지 평가 과정을 중단하는 것이다.**

  * | 단축평가 표현식     | 평가결과 |
    | ------------------- | -------- |
    | true \|\| anything  | true     |
    | false \|\| anything | anything |
    | true && anything    | anything |
    | false && anything   | False    |

* 단축평가를 사용하면 if 문을 대체할 수 있다. 

  * 주어진 조건이 truthy값 일때, 무언가를 해야한다면, 논리곱 연산자(&&) 표현식으로 if문을 대체할 수 있다.

    ```javascript
    var done = true;
    var message = '';
    
    //주어진 조건이 true일 때
    if (done) message = '완료';
    
    //if 문은 단축 평가로 대체 가능하다.
    message = done && '완료';//done이 true지만 뒤의 완료에 의해서 값이 평가되기 때문에 '완료'가 message에 할당된다.
    console.log(message); // 완료
    ```

  * 주어진 조건이 Falsy값 일 때, 무언가를 해야한다면 논리곱연산자(||)표현식으로 if문을 대체할 수 있다.

    ```javascript
    var done = false;
    var message = '';
    //주어진 조건이 false일 때,
    if (!done) message = '미완료';
    //if문은 단축평가로 대체 가능
    message = done || '미완료';
    console.log(message);//미완료
    ```

  ## 5. 논리 연산자

  * 우항과 좌항의 피연산자를 논리 연산한다.

  * &&, || , !(논리부정)

  * 논리부정연산자는 언제나 불리언 값을 반환하지만, 피연산자가 반드시 불리언 값일 필요는 없다. 만약 피연산자가 불리언값이 아니라면, 불리언 타입으로 암묵적 타입변환된다.

  * 드 모르간의 법칙

    ```javascript
    !(x || y) === (!x && !y)
    !(x && y) === (!x || !y)
    ```

  ## 6. 쉼표 연산자

  * 쉼표(,)연산자는 왼쪽 피연산자부터 차례대로 피연산자를 평가, 마지막 피연산자의 평가가 끝나면 마지막 평가 결과를 반환한다.

    ```javascript
    var x, y, z;
    x = 1, y = 2, z = 3; //3
    ```

  

  # 10. 객체 리터럴

  ## 1. 객체란?

  * 다양한 타입의 값(원시값 또는 다른 객체)들을 하나의 단위로 구성한 복합적인 자료구조이다. 원시값은 변경불가능한 값이지만, 객체 타입의 값, 즉 객체는 변경가능하다.

  * 자바스크립트에서 사용하는 모든 값들은 프로퍼티 값으로 사용 될 수 있다.

  * 자바스크립트의 함수는 일급 객체이므로 값으로 취급할 수 있다. 따라서 프로퍼티 값에 함수가 올 수 있다. 이 경우의 함수는 메소드 라고 부른다.
  * 객체는 0개 이상의 프로퍼티를 포함해야 한다. 따라서 프로퍼티가 있을수도 , 메소드가 있을수 없을수도 있다.
  * 프로퍼티: 객체의 상태를 나타내는 값(data), 메소드: 프로퍼티(상태 데이터)를 참조하고 조작할 수 있는 동작(behavior)

  ## 2. 객체 리터럴에 의한 객체 생성

  * 인스턴스(instance): 클래스에 의해 생성되어 메모리에 저장된 실체이다. 클래스는 인스턴스를 생성하기 위한 템플릿의 역할을 한다. 인스턴스는 객체가 메모리에 저장되어 실제로 존재하는 것에 초점을 맞춘 용어이다.

  * 자바스크립트는 프로토타입 기반 객체지향 언어로써, 클래스 기반 객체지향 언어와는 다른 다양한 객체생성 방법이 존재

    * 1) 객체 리터럴
    * 2) object 생성자 함수
    * 3) 생성자 함수
    * 4) object.create 메소드
    * 5) 클래스(es6)

  * 객체 리터럴:  객체를 생성하는 표기법. 객체 리터럴은 중괄호 내에 0개 이상의 프로퍼티를 정의한다. 변수에 할당이 이루어지는 시점에 자바스크립트 엔진은 객체 리터럴을 해석하여 객체를 생성한다.

  * 프로퍼티를 정의하지 않으면 빈 객체가 생성된다.

    ````javascript
    var empty= {}; //빈객체
    console.log(typeof empty);//object
    ````

  * 객체 리터럴의 중괄호는 코드블록을 의미하지 않는다. 코브블록의 닫는 중괄호 뒤에는 세미콜론을 붙이지 않는다. 하지만 객체 리터럴은 값으로 평가되는 표현식이다. 따라서 객체리터럴의 닫는 중괄호 뒤에는 세미콜론을 붙인다.

  * 객체 리터럴은 자바스크립트의 유연함과 강력함을 대표하는 객체 생성방식이다. 객체를 생성하기 위해 먼저 클래스를 정의하고 new 연산자와 함께 생성자를 호출할 필요가 없다. 객체를 생성한 이후에 프로퍼티를 동적으로 추가할 수도 있다.

  

  ## 3. 프로퍼티

  * 객체는 프로퍼티들의 집합이며, 프로퍼티는 키와 값으로 구성된다. 프로퍼티는 쉼표로 구분해서 나열한다. 마지막 프로퍼티의 뒤에는 쉼표를 쓰지않아도 된다.

  * 프로퍼티 키: 빈문자열을 포함하는 모든 문자열 또는 symbol 값

  * 프로퍼티 값: 자바스크립트에서 사용할 수 있는 모든 값

  * 프로퍼티 키 명명 규칙

    ```javascript
    var person = {
      firstname: 'yongmin',
      'last-name': 'kim'
    }; //last-name의 마이너스기호는 네이밍규칙에 위배되므로 따옴표를 생략 할 수 없다.
    ```

  * 빈 문자열을 프로퍼티 키로 사용해도 에러는 발생하지 않지만, 키로써(식별자의 한종류 로써) 의미를 갖지 못하므로 하지말자.

  * 프로퍼티 키를 0,1,2 같이 숫자로 명명해준다면, 암묵적 타입변환을 통해서 문자열이 된다. 내부적으로 모두 문자열로 변환된다.

  * 프로퍼티 키에 예약어를 프로퍼티 키로 사용해도 에러가 발생하지 않지만, 예상치 못한 에러가 발생할 수 도 있으므로 하지말자.

  * 이미 존재하는 프로퍼티 키를 중복선언하면 나중에 선언한 프로퍼티가 덮어 쓰게 된다. 에러는 발생하지 않으므로 주의하자.

  

  ## 4. 메소드

  * 자바스크립트에서는 프로퍼티 값으로 모든값을 사용할 수 있다.(함수도 값으로 취급된다.)
  * 프로퍼티 값이 함수일 경우, 일반 함수와 구분하기 위해서 메소드라고 부른다. 메소드는 객체에 제한되어 있는 함수를 의미한다.



	## 	5. 프로퍼티 접근

   * 마침표 표기법(dot notation) 또는 대괄호 표기법(bracket notation)을 사용하여 프로퍼티 값에 접근한다.

   * 프로퍼티 키가 식별자 네이밍 규칙을 따르는 이름, 자바스크립트에서 사용가능한 유효한 이름이면 마침표 표기법과 대괄호 표기법 모두 사용가능.

   * 마침표 또는 대괄호의 좌측에는 객체로 평가할 수 있는 표현식을 기술. 마침표의 우측 또는 대괄호의 내부에는 프로퍼티 키를 지정

   * ```javascript
     var person = {
       name: 'kim'
     };
     
     console.log(person.name); //kim 마침표 표기법
     console.log(person['name']); //kim 대괄호 표기법 , 따옴표가 없으면 name을 프로퍼티 키가아닌 식별자로 인식하여 에러.
     ```

   * 객체에 존재하지 않는 프로퍼티에 접근한다면, undefined를 바환한다. referenceError가 발생하지 않음. 주의!

   * ```javascript
     var person = {
       'last-name': 'kim',
       1: 10
     };
     
     console.log(person['last-name']);//kim
     console.log(person['1']); // 10
     console.log(person[1]);//10 ->이것이 가능한 이유는 1을 내부적으로 문자열로 변환하기 때문이다.
     //위의 대괄표 표기법으로 참조해야 하는 경우.
     ```

   * 프로퍼티를 삭제하고 싶은경우는 delete연산자를 사용한다.

   * ```javascript
     var person ={
       name: 'kim'
     };
     person.address = 'seoul';
     
     delete person.address;//동적으로 추가된 프로퍼티를 삭제했다.
     delete person.age;//존재하지 않는 프로퍼티를 삭제하려 할 경우는 에러가 발생하지 않고 무시된다.
     ```



## 6. ES6에 추가된 객체 리터럴의 확장 기능

* 1) 프로퍼티의 축약표현 (프로퍼티 값으로 사용한 변수와 프로퍼티 키가 같은경우)

  ```javascript
  //ES5
  var x = 1, y = 2;
  var obj={
    x:x,
    y:y
  };
  console.log(obj); // {x:1, y:2}
  
  //ES6
  let x = 1, y = 2;
  const obj = { x, y };//프로퍼티 축약표현
  console.log(obj);//{x:1, y:2}
  ```

* 2) 메소드 축약표현

  ```javascript
  //es5
  var obj = {
    name: 'kim',
    sayHi: function(){
      console.log('hi! ' + this.name);
    }
  };
  obj.sayHi(); // hi! kim
  
  
  //es6
  const obj = {
    name: 'kim',
    sayHi() {//이것이 함수의 이름이자 키가 된다.
      console.log('hi! ' + this.name);
    }
  };
  obj.sayHi(); // hi! kim
  //이 방식은 es5 es6의 함수가 내부적으로는 다르게 동작한다는 것을 인지하자.
  ```

  