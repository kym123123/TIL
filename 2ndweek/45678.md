# 4. 변수

## 1. 변수란?

* 메모리: 여러개의 데이터를 저장할 수 있는 공간을 가지고 있으며, 각 공간(메모리 셀)마다 주소를 가지고 있다. ->메모리 주소
* 컴퓨터가 연산을 하기 위해서는 연산되는 숫자들의 주소를 기억하고 있어야 한다. 연산의 결과 값도 메모리에 저장을 해놓아야 한다.
* 연산을 위한 숫자, 연산의 결과값 등을 재사용하기 위해서는 해당 숫자들이 있는 메모리셀에 접근하기위한 방법이 있어야한다. 이 방법을 제공하는 것이 변수이다.
* 프로그래밍 언어는 기억하고 싶은 값을 메로리에 저장하고, 저장된 값을 읽어들여 재사용 하기 위해 변수라는 메커니즘을 제공한다.
* 변수: 하나의 값을 저장할 수 있는 메모리 공간 자체, 또는 그 메모리 공간을 식별하기 위해 붙인 이름.
* 변수 이름을 통해서 언제든지 원하는 메모리 공간에 접근해서 참조 할수 있다. 

## 2. 변수 선언

* 변수를 생성하는 것이다. Var, let, const 키워드를 통해서 선언한다.
* 키워드: 자바스크립트와 약속한 명령어, 자바스크립트는 var, let, const를 만나면 뒤에오는 이름으로 변수를 생성하라 라고 인식한다.
* 변수 선언문이 실행되면, 빈 메모리 공간을 확보하고 메모리 공간의 주소를 기억하는 변수가 생성된다.
* 변수가 생성되고 값을 할당하지 않아도, undefined라는 값으로 변수값이 초기화 된다.
* var, let 키워드는 선언하고 값을 할당하지 않을경우 undefined로 변수값이 자동으로 초기화된다. const의 경우는 값을 선언하고 어떠한 값으로 초기화 해주지 않으면 error message가 발생한다.
* Var(es5 이전 까지), let,const(es6이후 새롭게 도입)
* var 키워드는 스코프 이슈, 중복선언 이슈가 있다.

## 3. 변수 호이스팅

* 자바스크립트 엔진이 자바스크립트를 실행 할 때, 한줄 한줄 순차적으로 처리하기 이전에 코드내의 선언문들을 먼저 처리하기 때문에, 선언문이 코드의 위로 끌어올려진 것처럼 동작하는 것이다.

* let,const로 선언한 변수들은 호이스팅이 되지 않는 것처럼 동작한다.

* ```javascript
  console.log(score);
  var score;//변수 선언문
  score = 10;//변수 할당문
  ```

* 변수 할당문은 코드가 실행되면 한줄한줄 처리되기 때문에, console.log를 할당문 이전에 입력하면 undefined가 출력된다.

## 4. 값의 할당

* 값의 할당= 변수 할당, 할당연산자(=)의 우측에 값이 오고, 좌측에 변수가 온다.
* 값을 저장하기 위해서, 일정크기의 메모리 공간을 확보한다.(다른프로그램이 해당 공간을 사용할 수 없게 된다.)
* 값의 주소는 변수명이 기억하게 되고, 변수명을 통하여 해당 메모리 공간에 저장되어 있는 값을 참조(재사용)할 수 있다.
* 변수는 암묵적으로 undefined로 값이 초기화(최초로 값을 할당하는 것) 된다.
* 특정한 값을 변수에 넣어주게 되면, undefined가 할당된 메모리 공간이 아닌 새로운 공간을 확보하여 특정한 값을 할당하게 된다.undefined는 원시값(변경불가능한 값)이기 때문에 변경될수 없어서 지우고 새로운 값을 넣어줄 수 없기 때문이다.

## 5. 값의 재할당

```javascript
var score = 80;//변수의 선언과 값의 할당
score = 90;//재할당
```

* var score=80;은 하나의 문이지만, 자바스크립트 엔진은 이를 선언과 할당이라는 두가지 과정으로 인식하여 실행시킨다.

  ```javascript
  var score;
  score=80;//이렇게 인식하고 실행시킴.
  ```

* const 키워드로 선언한 변수(상수)는 재할당을 할 수 없다.

## 6. 식별자

* 어떤 값을 구별해내서 식별할 수 있는 고유한 이름이 식별자이다.
* 메모리의 어떤 값(원하는 값)을 정확하게 가져올 수 있는 이름이다.
* 변수의 이름도 식별자이다. 식별자는 값을 기억하고 있는 것이 아니고, 메모리의 주소를 기억하고 있는 것이다. 이를 통해서 원하는 값에 접근할 수 있도록 한다.
* 따라서 식별자는 메모리공간에 붙인 이름이라고 할 수 있다.
* 함수, 클래스의 이름도 모두 식별자이다. 메모리상에 존재하는 어떠한 값을 식별해 낼수 있는 것이라면 모두 식별자이다.
* 식별자에는 네이밍 규칙이 정해져있다.
  * 1) 식별자는 특수문자를 제외한 문자, 숫자, _, $ 를 포함할 수 있다.
  * 2) 식별자는 특수문자를 제외한 문자, _, $ 로 시작할 수 있지만 숫자로는 시작할 수없다.
  * 3) 예약어(키워드로 사용하기 위해서 미리 확보된 단어들)는 식별자로 사용할 수 없다. Ex) function, var, let...
* 식별자는 직관적으로 무언가를 의미하는지를 알 수 있도록 네이밍 하는것이 좋다. 의미없이 x, y..등을 사용하는 것은 좋지않음. 다른 사람이 보았을 때도 이해할 수 있도록하며, 변수의 존재목적을 쉽게 알수 있도록 의미를 명확히 표현해 준다. -> 좋은 변수명은 코드의 가독성을 높여준다.
* 네이밍 컨벤션
  * 1) 카멜 케이스 : var firstName;
  * 2) 스네이크 케이스 : var first_name;
  * 3) 파스칼 케이스 : var FirstName;
  * 4) 헝가리언 케이스 : var strFirstName; //type + identifier

# 5. 표현식과 문

## 1. 값

* value는 어떤 식(표현식)을 평가한 결과를 말한다. 

* 변수는 하나의 값을 저장하기 위해 확보한 메모리 공간 자체 또는 그 메모리 공간을 식별하기 위해 붙인 이름이다. 따라서 변수에는 값을 할당해야 한다.

* ```javascript
  var sum = 10 + 20;//30
  //변수에는 표현식의 평가값인 30이 할당된다.
  ```

* 결국 값은 실제 메모리에 저장되는 최소 단위라고 할 수 있다.

## 2. 리터럴

* 리터럴은 사람이 이해할 수 있는 문자, 약속된 기호를 사용하여 값을 생성하는 방식이다.

* 숫자 3은 단순히 숫자가 아닌 숫자 리터럴이다. 자바스크립트 엔진은 3이라는 리터럴을 읽고 평가하여 숫자값 3을 생성하게 된다. 값을 평가하기 전에는 3이라는 숫자값이 아닌 리터럴3이다.

* 리터럴은 평가되어 값을 생성하는 문자(literal)로 기술된 코드. 사람이 이해할 수 있는 문자(숫자,알파벳,한글 등) 또는 미리 약속된 기호로 이루어져 있다. 리터럴을 이용하여 다양한 종류의 값을 생성할 수 있다.

* 정수리터럴(100), 부동소수점 리터럴(13.4), 2진수 리터럴(0b010001), 8진수 리터럴(0o101), 16진수 리터럴(0x41), 문자열 리터럴 ('hello'), 불리언 리터럴(true, false), null리터럴(null),

  undefined리터럴(undefined), 객체 리터럴({name: 'lee', age: '19'}), 배열리터럴([1,2,3]), 함수 리터럴(function(){}), 정규표현식 리터럴

* **리터럴이라는 표기법을 사용하면 값이 생성된다.**

* 리터럴을 코드에 기술하면, 자바스크립트 엔진은 코드가 실행되는 시점(런타임)에 리터럴을 해석하고 값을 생성한다. **리터럴은 값을 생성하기 위해 미리 약속한 표기법(notation)이라고 할 수 있다.**

## 3. 표현식

* 표현식(expression)은 값(value)으로 평가(evaluation)될 수 있는 문(statement)이다. 즉 **표현식은 평가되어 값을 생성하는 문이다**. 리터럴도 값으로 평가되기 때문에 표현식이다.

* 값으로 평가 될 수 있으면 표현식이다. 식별자도 값으로 평가 될수 있으므로 리터럴이다. 

* 함수는 호출하면 값으로 평가되기 때문에, 함수호출문은 표현식이다. 

* **표현식이라는 것은 값으로 평가된다는 점이 중요하다.**

  ```javascript
  //리터럴 표현식
  10
  'hello'
  //식별자 표현식(선언이 이미 존재한다 가정)
  sum
  person.name
  arr[1]
  //연산자 표현식
  10+20//30으로 평가되기 때문에 표현식
  sum=10
  sum!==10
  //함수/메소드 호출 표현식(선언이 이미 존재한다 가정)
  square()
  person.getName()
  ```

* 표현식과 표현식이 생성한 값은 동등한 관계, 동치(equivalent)이다. 표현식은 값처럼 사용할 수 있다.

## 4. 문

* **문은 프로그램을 구성하는 기본단위이자 최소 실행단위.**

* 프로그램이라는 것은 문들의 집합으로 이루어진 것이며, 문을 작성하고 순서에 맞게 나열한 것이 프로그램이다.

* 문은 여러 토근(token)으로 구성된다. 토큰은 문법적인 의미를 가지며 문법적으로 더이상 나눌 수 없는 코드의 기본요소를 의미한다.

* ```javascript
  var sum = 1 + 2 ;
  // var, sum , =, 1 , +, 2, ; 모두 하나의 토큰들이다.
  ```

* 문은 명령문이라고도 부르며, 컴퓨터에게 내리는 명령이다. 문이 실행되면 명령이 실행되고 무슨 일인가가 일어난다.(ex.변수선언문이 실행되면, 변수가 선언된다.)

* ```javascript
  //변수선언문
  var x;
  // 표현식 문(할당문)
  x=5;
  //함수 선언문
  function foo(){}
  //조건문
  if(x>1){console.log(x);}
  //반복문
  for(var i = 0; i<2; i++){console.log(i);}
  ```

* 문은 세미콜론으로 끝나야 한다. 0개 이상의 문을 중괄호로 묶은 코드블록{...}의 뒤에는 세미콜론을 붙이지 않는다.

* 자바스크립트엔진에는 세미콜론을 문의 끝이라고 예측되는 지점에  자동으로 붙여주는 asi 기능이 있기 때문에 꼭 붙여야 하는것은 아니다. 하지만 개발자의 예측과 다르게 세미콜론이 붙는 경우가 있기 때문에, 붙이는 것이 좋다.

## 5. 표현식인 문과 표현식이 아닌 문

* 변수 선언문은 값으로 평가될 수 없기에 표현식이 아니다.

  ```javascript
  var x;//변수선언문은 값으로 평가 될 수 없다. 변수에 할당 불가.
  ```

* 표현식과 문을 구별하는방법

  * 표현식인문과 표현식이 아닌문으로 구별한다. 표현식인문은 값으로 평가될 수 있는 문이고, 표현식이 아닌문은 값으로 평가될 수 없는 문이다.

* 변수 할당문은 값으로 평가 될 수 있기에 표현식이다. 따라서 할당문은 변수에 할당할 수 있다.

  ```javascript
  var foo = x =100;// 변수 할당문은 100으로 평가 될 수 있기때문에 foo라는 변수에 할당이 될 수 있다.
  ```

* 조건문도 값으로 표현될 수 없기에 표현식이 아니고 변수에 할당될 수 없다.

* 표현식인 문을 실행하면 평가된 값을 반환시킨다. 표현식이 아닌문은 undefined를 반환한다.

# 6. 데이터 타입

## 1. 숫자 타입

* 자바스크립트는 원시타입과 객체타입으로 분류할 수 있다.

* 원시타입(primitive type) : 숫자, 문자열, 불리언, undefined, null, symbol - > 변경할 수 없는 값. immutable value

* 객체타입(object/reference type) : 객체, 함수, 배열 등.

  ->	변경할 수 있는값. mutable value

* 1을 숫자로 선언할 수 있고, 문자로 선언할 수 있다. 숫자타입과 문자열 타입은 확보해야 할 메로리 공간의 크기도 다르고 읽어들여 해석하는 방식도 다르다. 저장되는 2진수도 다르다.

* 값을 생성한 목적과 용도도 다르다. 

* 숫자타입=산술연산을 위해서 생성.  문자타입 = 텍스트를 화면에 출력하기 위해서 생성.

* 자바스크립트는 숫자타입이 단 한가지 종류한다. 실수도 정수도 하나의 타입으로 배정밀도 64비트 부동소수점 형식의 2진수로 저장된다. 여러 진수의 수를 표현하기 위한 데이터 타입의 제공이 없기에, 이들 값을 참조하면 모두 10진수로 해석된다.
* 변수에 값이 할당되는 시점에, 값에 의해서 변수의 타입이 결정된다.
*  infinity, -infinity, NaN(not a number)은 모두 숫자타입이다.

## 2. 문자열 타입

* 문자열은 텍스트 데이터를 나타내는데 사용. 한글자는 16bit(2byte)를 소비한다.

* 전세계 대부분의 문자를 표현할 수 있다. 작은따옴표(''),큰 따옴표(""), 백틱(``)안에 텍스트를 넣어 생성한다.

* 일반적으로 문자열을 만들기 위해서 작은따옴표를 사용한다.

* 작은따옴표로 감싼 문자열 내의 큰따옴표는 문자열로 인식된다.

* 큰 따옴표로 감싼 문자열 내의 작은따옴표는 문자열로 인식된다.

* 작은따옴표로 감싼 문자열 내에 또다시 작은따옴표로 감싼 문자열은 에러를 발생시킨다. syntaxError: unexpected identifier

* 작은따옴표로 다시 감싸주고싶다면 아래와같이 백슬래쉬로 같이 감싸준다.

  ```javascript
  var str = '작은따옴표로 감싼 \'문자열내에 다시 작은따옴표로\' 감싸기';
  ```

* 따옴표로 문자열을 감싸주지 않으면 문자열의 시작과 끝을 알기 어렵고, 식별자와 혼동하기 쉽다.

* ```javascript
  var string = hello;//따옴표로 감싸지 않아서 hello를 식별자로 인식하고 엔진이 hello식별자를 찾기 시작하게 된다.
  ```

* 따옴표로 감싸지 않는다면 스페이스같은 공백을 포함시킬 수 없는 문제도 생긴다.

## 3. 템플릿 리터럴

* es6부터 새롭게 도입된 방법으로 백틱(``)을 이용하여 감싸는 방법이다.

* 일반 문자열 내에서는 줄바꿈을 허용하지 않는다. 템플릿 리터럴 내에서는 줄바꿈이 허용된다.

* 이전까지는 이스케이프 시퀀스를 이용하여 줄바꿈을 해주었다.

* 이스케이프 시퀀스 (ex. '\n'은 줄바꿈, '\t'은 탭..등등)을 사용하지 않으면 es5에서는 문자열 내에서 엔터키를 사용해서 인위적인 개행을 해 줄수 없었따.

* ```javascript
  var template = `<ul>
  	<li>home</li>
  </ul>`; //템플릿 리터럴은 개행이 그대로 문자열로 취급되어 보여진다.
  ```

* 표현식 삽입-> 문자열은 문자열 연산자(+)를 사용하여 연결할 수 있다. + 연산자는 피연산자 중 하나이상이 문자열일 경우, 문자열 연결 연산자로 동작한다.

* ```javascript
  var first = 'yongmin';
  var last = 'kim';
  console.log('my name is' + first + ' ' + last);//es5방식의 문자열 연결
  ```

* ```javascript
  console.log(`my name is ${first} ${last}.`); //es6이후의 표현식 삽입방식.
  ```

* 표현식 삽입은 표현식의 평가 결과가 문자열이 아니더라도 강제 타입 변환되어 삽입된다.

  ```javascript 
  console.log(`1+2=${1+2}`);//1+2=3으로 출력
  ```

## 4. 불리언 타입

* 불리언 타입은 논리적 참(true), 거짓(false)를 나타낸다.
* 프로그램의 흐름을 제어하는 조건문에서 자주 사용된다.

## 5. Undefined 타입

* 선언이후에 명시적으로 값을 할당하지 않은 변수는, 자바스크립트 엔진에 의해서 암묵적으로 초기화되는데, undefined값을 갖게된다.
* 주 목적은, 선언하였지만 초기화 하지않은 변수에 자바스크립트 엔진이 암묵적으로 값을 할당해주기 위함이다. 개발자가 인위적으로 이 값을 변수에 넣어줄 일은 없다. 이는 혼란을 가중시킨다.
* 우리가 어떠한 값을 참조하였을때, undefined를 출력받는다면 이 값에는 아무것도 할당해주지 않았다고 생각하기 때문에, 인위적으로 할당해주면 다른 개발자들의 혼란이 커진다.
* 변수에 값이 없다고 얘기해주고 싶은 경우에는 null을 할당해주도록 한다.

## 6. null 타입

* null type은 null이 유일하다. 대소문자를 구분하기때문에 null이라고 기입한다.
* 어떤 변수를 참조하였을때, null이 나오면 개발자가 의도적으로 값이 없다는것을 명시하려 한것을 알 수 있다.
* 함수가 반환할 값이 없을경우에는 null을 반환하기도 한다.

## 7.symbol타입

* es6에 새롭게 추가된 변경불가능한 원시타입이다.

* 이 값은 리터럴이 존재하지 않고 반드시 symbol함수를 통해서 생성한다.

* ```javascript
  var key = Symbol('key');//심볼값 생성함수
  ```

## 8. 객체타입

* 원시타입이 아닌 모든것들을 객체타입이라고 부른다.
* 자바스크립트는 객체기반의 언어로, 거의 대부분이 객체로 이루어져 있다. 다른장에서 집중적으로 다룰것,,,

## 9. 데이터 타입의 존재 이유

* 자바스크립트 엔진은 데이터타입, 값의 종류에 따라 정해진 크기의 메모리 공간을 확보한다. 변수에 할당되는 값의 데이터 타입에 따라서 확보해야할 메모리 공간의 크기가 결정된다.

* 값을 참조할 때, 몇 바이트를 한번에 읽어들여야 할지 결정해야 한다. 8바이트짜리 데이터를 4바이트만 읽어들인다면, 데이터가 훼손되어서 보여진다.

* 값을 데이터 타입에 의해서 잘 저장하고 잘 읽어들일수 있게 한다.메모리에서 읽어들인 2진수를 어떻게 해석해야 하는지에 대한 문제가 남아있다. ->2진수는 어떻게 해석하는지에 따라서 전혀 다른값이 된다. 

* ex> 01000001을 숫자로 해석하면 65이지만, 문자열로 해석하면 

  'A'이다. **저장되어있는 2진수의 해석방법을 알아야 원하는 데이터를 출력할 수 있다. 이러한 해석방법을 제공하는 것이 데이터 타입이다.**

* 데이터 타입이 없다면, 메모리에 저장할 때, 얼마만큼의 메모리 공간을 확보해야 하는지, 데이터를 참조할 때 몇 바이트 단위로 읽어들여야 하는지, 메모리에 저장된 2진수 값을 어떻게 해석해야 하는지도 알 수 없게 된다.

* 1) 값을 저장할 때 확보해야 하는 메모리 공간의 크기를 결정

* 2) 값을 참조할 때 한번에 읽어 들여야 할 메모리 공간의 크기를 결정하기 위해

* 3) 메모리에서 읽어들인 2진수를 어떻게 해석할 지를 결정하기 위해

## 10. 동적 타이핑

* 자바스크립트의 모든 값은 데이터 타입을 갖는다.

* 정적타입 언어는 변수 선언시 데이터 타입을 명시해야 한다.

* 정적타입 언어는 변수의 타입의 변경이 불가하며, 타입체크를 통과하지 못하면 에러가 발생하며 프로그램 실행이 막힌다.

* 이렇게 일관성을 강제하여 안정적인 코드를 구현시킨다.

* 자바스크립트는 동적타입 언어로써, 변수선언시 데이터 타입을 선언하지 않고 var 키워드를 이용한다.

* typeof 연산자로 데이터 타입을 조사할 수 있다.

* null은 typeof 로 데이터 타입을 조사하면 object가 출력된다.(주의)

* 변수의 타입이 있을까? -> typeof로 변수의 타입을 출력시키면 나오는 값은 변수의 타입이 아니라, 변수에 현재 할당되어 있는 값의 타입을 반환하는 것이다.

* 자바스크립트는 어떤 타입의 값이라도 자유롭게 할당이 가능하다. 정적언어와는 다른 데이터 타입의 개념을 가지고 있다. 값을 할당하는 시점에 변수의 타입이 동적으로 결정되며, 변수의 타입은 고정되어 있지 않고, 재할당 되는 값에 의해서 언제든지 동적으로 변할수 있다.

* 따라서, **기본적으로 변수는 타입을 갖지 않는다.(var) 하지만 값은 명확히 타입을 가지고 있다. 값의 타입에 따라서 변수의 타입이 동적으로 변경되는 것이다.**

* 이러한 편리한 변수타입 변경 가능성은 이점도 있지만 단점도 있다. 현재 변수내의 값을 추적하기에 어려울 때가 있다. 정적타입 언어는 한번 선언한 타입이 변하지 않기에, 이로인해서 곤란할 일이 없지만 자바스크립트에서는 변수의 타입이 값의 타입에 의해서 변하기 때문에, 변수내의 값에 정확히 이해가 없다면 이를 잘못 예측하여 오류를 발생시키기 쉽다. 

  (편리성 high, 신뢰성 low->trade-off)

* 모던 자바스크립트에서는 타입을 가지고있는 타입스크립트를 많이 사용하기도 한다.

* 변수를 사용하지 않을 수 없지만, 되도록이면 변수의 사용을 적극적으로 줄여서 오류 발생 가능성을 낮추자.

* 전역변수(어디에서든 참조할 수 있는 변수)의 사용을 금하자.

* 변수의 생명주기(스코프)를 최대한 짧게 만들도록 한다.

* 변수의 값이 변하는 경우가 아니라면, 변수보다는 상수를 사용하여 값의 변경을 억제하는 것이 좋다. **const** 키워드를 사용하면 상수 선언이 가능하다.

* 변수를 이름지을 경우, 변수의 존재 이유를 파악할 수 있도록 명명한다. -> 오해를 불러일으키거나 실수를 야기할 가능성이 낮아진다.

# 7. 연산자

## 1. 이항 산술 연산자

* 연산자는 하나 이상의 표현식을 대상으로 산술, 할당, 비교, 논리, 타입, 지수연산 등을 수행해 하나의 값을 만든다.