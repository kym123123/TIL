# 클래스형 - 함수형

* 함수형: 렌더링에 필요한 상태값들은 하나의 함수형 컴포넌트 안에서 상수로써 존재하는 것이다. 변하는 값으로써 참조되는 것이 아니다. (렌더링된 값을 고정시키는 함수형 컴포넌트의 특징). 함수형 컴포넌트는 클래스의 this 참조와는 다르게, this를 참조하지 않기 때문에, 어떠한 props, state를 바라보는 경우에, react가 이를 변경하지 않는다. <u>render 될 때 바라보는 state, props의 값을 유지하는 것이다</u>. 이 특성은 함수형 컴포넌트의 hooks에 같은 원리로 적용된다. 

  함수형 컴포넌트에서 setTimeout함수등을 이용하여 넘겨준 state, props를 결과로 받아보기 전에, 연이어서 상태의 변경을 해주어도, 결과로 돌아오는 state, props는 그 setTimeout함수를 실행시키며 넘겨준 시점의 state, props를 반환하게 된다. 위에 적어놓았듯이 참조하면서 값의 변화를 추적하는 것이 아닌, 렌더링 되는 시점 마다의 값을 상수로써 가지고 있기 때문에 발생하는 일이다. 

  따라서 나중에 state, props를 반환 받더라도, 이 값을 최신의 state나 props를 받고 싶다면, useRef를 사용하는 방법이 있다. useRef는 클래스형에서 this 참조처럼 this가 변하는 행동을 함수형에서 할수 없는 것을 보완하는 용도로 사용 가능하다. useRef는 함수형 컴포넌트가 유지가 되는 한 새로 생성되거나 사라지거나 하지 않고, 그 컨테이너는 고유하게 유지되므로 그 내부에 값을 안전하게 담아둘 수 있다. 또한 이 값은 render들끼리 공유가 가능하다. 

  항상 최신화된 state, props를 전달받고 싶은 로직을 작성할 경우에 state나 props를 바꾸는 시점에 useRef.current도 같이 바꿔주면 되는 것이다. 이 행동을 직접하면 실수를 하기 쉬우므로, useEffect안에서 의존성을 설정해주고(useRef에 담을 state, props로 의존성 부여)useRef.current = 새로운 상태값 으로 할당해주면, 최신화 로직을 자동화 해 줄수 있다.

* 클래스형: state, props를 사용할 경우, this.props.xxx, this.state.xxx처럼 this를 참조한다. 이 this 참조로 인하여 함수형과 다른 특성을 갖고있다. react는 props나 state는 불변의 성질을 가지고 있기 때문에 이를 변화하지는 못한다. 그러나 this는 변화 가능한 값이다. 위의 함수형에서 setTimeout의 예시처럼 한 시점에서 넘겨준 state혹은 props를 반환하는 함수를 호출하도록 위임 한 상태에서 state, props를 변경해주면, 나중에 내가 받는 결과값은 최신화된 state, props 값을 받아 볼 수 있는 것이다.  클래스형은 변화가능한 this참조의 특성으로 인하여, 함수형처럼 특정 render시점의 상태값을 반환하지 않고 최신상태로 바뀐 this.클래스형컴포넌트를 참조하게 되어서 가장 업데이트 된 값을 받게 되는것이다. 이는 어떠한 상황에서는 장점이지만, 버그로써 동작할 확률이 굉장히 높다.

  함수형 컴포넌트의 기본 특성처럼 특정 render시점에 묶인 상태값을 반환받고 싶다면? 추천하는 방법은 render메서드 안에서 상태값을 고정시켜두는것이다.

  ```javascript
  // ....
  render () {
    const fixedCount = this.state.count; // render 라이프 사이클 메서드가 실행되는 시점의 count값을 고정시킨다.
    
    setTimeout(() => {
      console.log(fixedCount); // 3000ms뒤에 콘솔창에 나타나는 값은 이때 고정한 count값이 된다.
    }, 3000);
    
    return (
    // 컴포넌트 반환 로직..
    );
  }
  ```

  이렇게 render 라이프사이클 메서드 안에서 값을 고정시키는 이유는, 새로운 상태값을 토대로 ui를 다시 그리는 과정의 가장 바로직전에 실행되는 render메서드이기 때문에, ui에 표현될 값을 갖게 되고, 이를 고정시켜 두는것이 특정 render시점의 값을 고정시키게 되는 것이기 때문이다. 다른 메서드에서 고정시켜두면 (ex: render 메서드 이전의 라이프사이클 메서드) 그 함수에서 넘겨준 고정된 state값을 setTimeout이 기억하게 되고, 그 이후에 render메서드가 실행되기전 상태가 또 다시 변경된다면, 버그가 발생하기 쉽기 때문이다. 



## useEffect의 특성

* <u>useEffect의 실행 순서는 다음과 같다.</u>

1. 어떠한 상태값을 바라보는 함수형 컴포넌트가 마운트 된다. (ex: count = 1인 시점의 렌더링)
2. ui가 화면에 렌더링 된다.
3. effect가 실행된다.
4. 상태값을 변경시켜준다. (count = 2로 변경됨)
5. count=2를 가지고 다시 ui를 화면에 렌더링 한다.
6. 렌더링 한 다음 이전 시점인 count=1에 정의해둔 clean up 함수를 실행시킨다.
7. clean up 함수가 실행 되고, count = 2시점에 정의된 effect를 실행시킨다.

착각하기 쉬운것이, 렌더링 -> effect실행 -> 상태 변경 요청 -> 클린업 실행 -> 새 상태를 토대로 렌더링 

이 순서라고 생각하기 쉽지만, 사실은 새로운 상태를 토대로 ui를 다시 렌더링 하기 전에 클린업을 하는 것이 아니라, ui를 다시 그리고 클린업을 하게 된다.

* 현재 render, 이전 render시점의 effect에서, deps에 넘겨준 값이 같다면, 동기화할 것이 effect에 존재하지 않는다 라고 react가 판단하고 effect를 스킵하게 된다.
* 필요한 최소한의 정보를 effect에서 컴포넌트로 전달해주는 것이 최적화에 도움이 된다.(필요이상의 재 렌더링을 막아준다.)
* 함수형 update를 사용하자. 함수형 업데이트에서 함수의 인자인 최신의 상태는, 상태값을 참조하는 것이 아닌 행동의 기술이기 때문에, 불필요한 재 렌더링을 막아주는 행동이다.
* 함수형 updater를 사용하더라도, 넘겨받은  props혹은 다른 state여러개를 이용하여 상태를 업데이트 해야하는 경우에는 useReducer를 사용한다.
* 컴포넌트가 유지되는 한, dispatch함수, setState메서드, useRef의 컨테이너 값은 항상 일정하다. 이러한 특성으로 의존성 배열에 넣어도 안넣어도 상관은 없지만, 일관되게 코드를 작성하기 위해서는 넣어주자. effect가 사용하는 값이니까!
* useReducer를 사용하여 상태를 업데이트 해주면, effect안에서 상태를 읽는대신에 어떠한 일이 일어났는지만을 알려주는 정보를 인코딩하는 action을 dispatch하는 것이다. 따라서 effect는 상태값을 참조하는 것으로 부터 분리가 가능하다.
* props를 읽어들여 상태를 업데이트하는 useReducer는 컴포넌트 안에 정의하여 props를 참조할 수 있도록 한다.
* react는 action을 기억해 둔다. 그리고 다음 render시에 dispatch를 하면, 최신 props와 state를 참조할 수 있게 되고, 다른 렌더링에 포함된 effect에서 호출된 dispatch가 최신의 state나 props를 참조할 수 있게 되는 것이다.

