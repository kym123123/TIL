# 13. 스코프

## 1. 스코프란?

* 모든 식별자( 변수 이름, 함수 이름, 클래스 이름 등)는 자신이 선언된 위치에 따라서 다른 코드가 식별자 자신을 참조 할 수 있는 유효범위가 결정된다. 이 유효 범위가 스코프이다.
* 스코프 : 식별자가 유효한 범위

```javascript
function add(x, y){
  console.log(x, y); //2 5
	return x + y;
}

add(2,5);

console.log(x,y); //referenceError : x is not defined. -> 매개변수는 함수 몸체 내부에서만 참조할 수 있다.-> 매개변수의 스코프(유효범위)는 함수 몸체 내부이다.
```

* 변수는 코드의 가장 바깥영역에서 뿐만 아니라, 함수 몸체 내에서도 선언할 수 있다. 

  ```javascript
  var var1= 1;//전역변수 var1
  
  if(true) {
    var var2 = 2; // 코드 블록 내에서 선언한 변수
    if (true) {
      var var3 = 3; // 중첩된 코드블록 내에서 선언한 변수
    }
  }
  
  function foo(){
    var var4 = 4; //함수 내에서 선언한 변수
    function bar(){
      var var5 = 5; //중첩된 함수 내에서 선언한 변수
    }
  }
  ```

* 식별자 결정(identifier resolution)

  ```javascript
  var x = 'global';
  
  function foo() {
    var x = 'local';
    console.log(x); // (1) ->local
  }
  foo();
  console.log(x);// (2) -> global
  ```

  전역에서와 foo함수 내부에 같은 이름을 갖는 변수 x 선언.

  (1)과 (2)에서 참조하는경우 자바스크립트 엔진은 이름이 같은 두개의 변수중 어떤 변수를 참조할 것인지 결정해야 한다. 자바스크립트 엔진은 스코프를 통해서 어떤 변수를 참조할 것인지 결정한다. -> 스코프: 엔진이 식별자를 검색할 때 사용하는 규칙

  자바스크립트 엔진은 코드를 실행할 때, 코드의 문맥(context)를 고려한다. 코드가 **어디에서** **실행되며** **어떤 코드가 있는지에 따라서 동일한 코드도 다른 결과를 만든다.**

* 코드의 문맥(context)과 환경(environment)

  * 1) 렉시컬 환경(lexical environment) : 코드가 어디서 실행되며 주변에 어떤 코드가 있는지. 코드의 문맥은 렉시컬 환경으로 이루어진다.
  * 2) 실행 컨텍스트(execution context) : 모든 코드는 실행 컨텍스트에서 평가되고 실행된다. 스코프는 실행 컨텍스트와 관련이 깊다.

* 코드의 가장 바깥영역(전역;global)에서 선언된 변수는 어디서든 참조가 가능하다. 그러나 foo함수 내에서 선언된 변수 x 는 함수 내부에서만 참조가 가능하고 외부에서는 불가능하다. 따라서 두개의 변수 x 는 이름이 동일하지만 자신이 유효한 범위인 스코프가 다른 별개의 변수이다.

* 식별자(identifier) : 변수나 함수의 이름과 같은 식별자는 어떤 값을 구별하여 식별해낼 수 있는 고유한 이름. 어떤 값을 구별할 수 있어야 하니까 유일해야 한다. -> 변수 이름은 중복될 수 없다. 하나의 값은 유일한 식별자에 연결(name binding)되어야 한다.

* 컴퓨터에서 다른폴더라면 이미 존재하는 파일이름을 똑같이 사용할 수 있듯이, 스코프가 다르면 동일한 이름을 가진 식별자를 사용하더라도 충돌을 방지 할 수 있다. -> 스코프는 네임스페이스다.

* Var 키워드로 선언된 변수는 같은 스코프 내에서 중복선언이 허용된다. 이는 의도치 않게 변수값이 재할당되는 부작용을 발생시킨다.

  ```javascript
  function foo(){
    var x = 1; 
    //var 변수선언은 같은 스코프 내에서 중복선언 허용.
    var x = 2;
    console.log(x); //2
  }
  
  //let이나 const 키워드로 선언된 변수는 같은 스코프 내에서 중복선언 허용하지 않는다.
  function bar() {
    let x = 1;
    let x = 2;//syntaxError: identifier x has already been declared
  }
  ```

## 2. 스코프의종류

| 구분 | 설명                  | 스코프      | 변수     |
| ---- | --------------------- | ----------- | -------- |
| 전역 | 코드의 가장 바깥 영역 | 전역 스코프 | 전역변수 |
| 지역 | 함수 몸체 내부        | 지역 스코프 | 지역변수 |

* 변수는 자신이 선언된 위치에 의해 자신의 스코프가 결정된다.
* 모든 스코프는 하나의 계층적 구조로 연결된다. 모든 지역 스코프의 최상위 스코프는 전역 스코프이다. 
* 스코프체인(scope chain) : 스코프가 계층적으로 연결된 것. 실행 컨텍스트의 렉시컬 환경을 단방향으로 연결한 것.
* 변수를 참조할 때, 자바스크립트 엔진은 스코프 체인을 통해 변수를 참조하는 코드의 스코프에서 시작하여 상위 스코프 방향으로 이동하며 선언된 변수를 검색한다. -> 상위 스코프에서 선언한 변수를 하위스코프에서도 참조한 이유이다.
* 자바스크립트 엔진은 스코프체인을 따라서 변수를 참조하는 스코프에서 시작해서 상위 스코프 방향으로 이동하며 선언된 변수를 검색한다. **절대로 하위 스코프로 내려가면서 검색하지 않는다.**
* 상위 스코프에서 유효한 변수는 하위 스코프에서도 자유롭게 참조가 가능하지만, 하위스코프에서 유효한 변수를 상위 스코프에서는 참조할 수 없다.
* 함수 선언문으로 함수를 정의하면, 런타임 이전에 함수 객체가 먼저 생성된다. 자바스크립트 엔진은 함수 이름과 동일한 이름의 식별자를 암묵적으로 선언하고 생성된 함수 객체를 할당한다. 함수도 식별자에 할당되기 때문에 스코프를 갖는다. 

## 3. 함수 레벨 스코프

* var 키워드로 선언된 변수는 오로지 함수의 코드블록(함수 몸체)만을 지역 스코프로 인정한다. 이러한 특성을 함수레벨 스코프 라고 한다.

  ```javascript
  var x = 1;//전역변수x
  if(true){
    var x = 10;//이미 선언된 전역변수x가 있으므로 중복선언된다.
  }
  //var 키워드로 선언된 변수는 함수의 코드블록만을 지역 //스코프로 인정한다. 따라서 새로 if문내에서 선언 할당한 변수 x도 전역변수로 취급된다.
  console.log(x); //10
  ```

  ```javascript
  var i = 10;
  for(var i = 10; i < 5; i++){
    console.log(i);
  }//for문에서 선언한 i는 전역변수다. 이미 선언된 i가 //있으므로 중복선언
  console.log(i);//5 원치않는 값의 재할당이 발생.
  ```

* 블록레벨 스코프를 지원하는 프로그래밍 언어에서는 for문에서 반복을 위해 선언된 변수가 for 문의 코드블록 내에서만 유효한 지역변수다.(외부에서 사용 불가) 

* var 키워드로 선언된 변수는 블록레벨 스코프를 인정하지 않기 때문에 i 변수는 전역변수가 된다. -> 중복 선언되어 의도치 않은 전역변수의 값이 재할당 됨.

* let, const키워드는 블록레벨 스코프를 지원한다.

## 4. 렉시컬 스코프(lexical scope)

```javascript
var x = 1;

function foo(){
  var x = 10;
  bar();
}
function bar(){
  console.log(x);
}
foo();//1 자바스크립트는 렉시컬스코프를 따르기 때문에 bar함수의 정의 위치인
//전역에서의 x 를 참조한다.
bar();//1
```

* Bar()함수의 상위 스코프가 무엇인지에 따라서 결과가 결정된다.

* 동적 스코프(dynamic scope) : 함수를 정의하는 시점에는 함수가 어디서 호출될지 알 수 없다. 따라서 함수가 호출되는 시점에 동적으로 상위 스코프를 결정한다. -> 함수를 어디서 호출했는지.

* 렉시컬 스코프(lexical scope) or 정적 스코프(static scope) : 함수 정의가 평가되는 시점에 상위 스코프가 정적으로 결정된다. 자바스크립트는 이 방식을 따른다. -> 함수를 어디서 정의했는지.

* **함수가 호출된 위치는 상위 스코프 결정에 어떠한 영향도 주지 않는다. 함수의 상위 스코프는 언제나 자신이 정의된 스코프이다.**

  

